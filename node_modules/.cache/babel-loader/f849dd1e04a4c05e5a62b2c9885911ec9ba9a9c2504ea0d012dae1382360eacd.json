{"ast":null,"code":"/**\n * @name MarkerClustererPlus for Google Maps V3\n * @version 2.1.2 [May 28, 2014]\n * @author Gary Little\n * @fileoverview\n * The library creates and manages per-zoom-level clusters for large amounts of markers.\n * <p>\n * This is an enhanced V3 implementation of the\n * <a href=\"http://gmaps-utility-library-dev.googlecode.com/svn/tags/markerclusterer/\"\n * >V2 MarkerClusterer</a> by Xiaoxi Wu. It is based on the\n * <a href=\"http://google-maps-utility-library-v3.googlecode.com/svn/tags/markerclusterer/\"\n * >V3 MarkerClusterer</a> port by Luke Mahe. MarkerClustererPlus was created by Gary Little.\n * <p>\n * v2.0 release: MarkerClustererPlus v2.0 is backward compatible with MarkerClusterer v1.0. It\n *  adds support for the <code>ignoreHidden</code>, <code>title</code>, <code>batchSizeIE</code>,\n *  and <code>calculator</code> properties as well as support for four more events. It also allows\n *  greater control over the styling of the text that appears on the cluster marker. The\n *  documentation has been significantly improved and the overall code has been simplified and\n *  polished. Very large numbers of markers can now be managed without causing Javascript timeout\n *  errors on Internet Explorer. Note that the name of the <code>clusterclick</code> event has been\n *  deprecated. The new name is <code>click</code>, so please change your application code now.\n */\n\n/**\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\n/**\n * @name ClusterIconStyle\n * @class This class represents the object for values in the <code>styles</code> array passed\n *  to the {@link MarkerClusterer} constructor. The element in this array that is used to\n *  style the cluster icon is determined by calling the <code>calculator</code> function.\n *\n * @property {string} url The URL of the cluster icon image file. Required.\n * @property {number} height The display height (in pixels) of the cluster icon. Required.\n * @property {number} width The display width (in pixels) of the cluster icon. Required.\n * @property {Array} [anchorText] The position (in pixels) from the center of the cluster icon to\n *  where the text label is to be centered and drawn. The format is <code>[yoffset, xoffset]</code>\n *  where <code>yoffset</code> increases as you go down from center and <code>xoffset</code>\n *  increases to the right of center. The default is <code>[0, 0]</code>.\n * @property {Array} [anchorIcon] The anchor position (in pixels) of the cluster icon. This is the\n *  spot on the cluster icon that is to be aligned with the cluster position. The format is\n *  <code>[yoffset, xoffset]</code> where <code>yoffset</code> increases as you go down and\n *  <code>xoffset</code> increases to the right of the top-left corner of the icon. The default\n *  anchor position is the center of the cluster icon.\n * @property {string} [textColor=\"black\"] The color of the label text shown on the\n *  cluster icon.\n * @property {number} [textSize=11] The size (in pixels) of the label text shown on the\n *  cluster icon.\n * @property {string} [textDecoration=\"none\"] The value of the CSS <code>text-decoration</code>\n *  property for the label text shown on the cluster icon.\n * @property {string} [fontWeight=\"bold\"] The value of the CSS <code>font-weight</code>\n *  property for the label text shown on the cluster icon.\n * @property {string} [fontStyle=\"normal\"] The value of the CSS <code>font-style</code>\n *  property for the label text shown on the cluster icon.\n * @property {string} [fontFamily=\"Arial,sans-serif\"] The value of the CSS <code>font-family</code>\n *  property for the label text shown on the cluster icon.\n * @property {string} [backgroundPosition=\"0 0\"] The position of the cluster icon image\n *  within the image defined by <code>url</code>. The format is <code>\"xpos ypos\"</code>\n *  (the same format as for the CSS <code>background-position</code> property). You must set\n *  this property appropriately when the image defined by <code>url</code> represents a sprite\n *  containing multiple images. Note that the position <i>must</i> be specified in px units.\n */\n/**\n * @name ClusterIconInfo\n * @class This class is an object containing general information about a cluster icon. This is\n *  the object that a <code>calculator</code> function returns.\n *\n * @property {string} text The text of the label to be shown on the cluster icon.\n * @property {number} index The index plus 1 of the element in the <code>styles</code>\n *  array to be used to style the cluster icon.\n * @property {string} title The tooltip to display when the mouse moves over the cluster icon.\n *  If this value is <code>undefined</code> or <code>\"\"</code>, <code>title</code> is set to the\n *  value of the <code>title</code> property passed to the MarkerClusterer.\n */\n/**\n * A cluster icon.\n *\n * @constructor\n * @extends google.maps.OverlayView\n * @param {Cluster} cluster The cluster with which the icon is to be associated.\n * @param {Array} [styles] An array of {@link ClusterIconStyle} defining the cluster icons\n *  to use for various cluster sizes.\n * @private\n */\nfunction ClusterIcon(cluster, styles) {\n  cluster.getMarkerClusterer().extend(ClusterIcon, google.maps.OverlayView);\n  this.cluster_ = cluster;\n  this.className_ = cluster.getMarkerClusterer().getClusterClass();\n  this.styles_ = styles;\n  this.center_ = null;\n  this.div_ = null;\n  this.sums_ = null;\n  this.visible_ = false;\n  this.setMap(cluster.getMap()); // Note: this causes onAdd to be called\n}\n\n/**\n * Adds the icon to the DOM.\n */\nClusterIcon.prototype.onAdd = function () {\n  var cClusterIcon = this;\n  var cMouseDownInCluster;\n  var cDraggingMapByCluster;\n  this.div_ = document.createElement(\"div\");\n  this.div_.className = this.className_;\n  if (this.visible_) {\n    this.show();\n  }\n  this.getPanes().overlayMouseTarget.appendChild(this.div_);\n\n  // Fix for Issue 157\n  this.boundsChangedListener_ = google.maps.event.addListener(this.getMap(), \"bounds_changed\", function () {\n    cDraggingMapByCluster = cMouseDownInCluster;\n  });\n  google.maps.event.addDomListener(this.div_, \"mousedown\", function () {\n    cMouseDownInCluster = true;\n    cDraggingMapByCluster = false;\n  });\n  google.maps.event.addDomListener(this.div_, \"click\", function (e) {\n    cMouseDownInCluster = false;\n    if (!cDraggingMapByCluster) {\n      var theBounds;\n      var mz;\n      var mc = cClusterIcon.cluster_.getMarkerClusterer();\n      /**\n       * This event is fired when a cluster marker is clicked.\n       * @name MarkerClusterer#click\n       * @param {Cluster} c The cluster that was clicked.\n       * @event\n       */\n      google.maps.event.trigger(mc, \"click\", cClusterIcon.cluster_);\n      google.maps.event.trigger(mc, \"clusterclick\", cClusterIcon.cluster_); // deprecated name\n\n      // The default click handler follows. Disable it by setting\n      // the zoomOnClick property to false.\n      if (mc.getZoomOnClick()) {\n        // Zoom into the cluster.\n        mz = mc.getMaxZoom();\n        theBounds = cClusterIcon.cluster_.getBounds();\n        mc.getMap().fitBounds(theBounds);\n        // There is a fix for Issue 170 here:\n        setTimeout(function () {\n          mc.getMap().fitBounds(theBounds);\n          // Don't zoom beyond the max zoom level\n          if (mz !== null && mc.getMap().getZoom() > mz) {\n            mc.getMap().setZoom(mz + 1);\n          }\n        }, 100);\n      }\n\n      // Prevent event propagation to the map:\n      e.cancelBubble = true;\n      if (e.stopPropagation) {\n        e.stopPropagation();\n      }\n    }\n  });\n  google.maps.event.addDomListener(this.div_, \"mouseover\", function () {\n    var mc = cClusterIcon.cluster_.getMarkerClusterer();\n    /**\n     * This event is fired when the mouse moves over a cluster marker.\n     * @name MarkerClusterer#mouseover\n     * @param {Cluster} c The cluster that the mouse moved over.\n     * @event\n     */\n    google.maps.event.trigger(mc, \"mouseover\", cClusterIcon.cluster_);\n  });\n  google.maps.event.addDomListener(this.div_, \"mouseout\", function () {\n    var mc = cClusterIcon.cluster_.getMarkerClusterer();\n    /**\n     * This event is fired when the mouse moves out of a cluster marker.\n     * @name MarkerClusterer#mouseout\n     * @param {Cluster} c The cluster that the mouse moved out of.\n     * @event\n     */\n    google.maps.event.trigger(mc, \"mouseout\", cClusterIcon.cluster_);\n  });\n};\n\n/**\n * Removes the icon from the DOM.\n */\nClusterIcon.prototype.onRemove = function () {\n  if (this.div_ && this.div_.parentNode) {\n    this.hide();\n    google.maps.event.removeListener(this.boundsChangedListener_);\n    google.maps.event.clearInstanceListeners(this.div_);\n    this.div_.parentNode.removeChild(this.div_);\n    this.div_ = null;\n  }\n};\n\n/**\n * Draws the icon.\n */\nClusterIcon.prototype.draw = function () {\n  if (this.visible_) {\n    var pos = this.getPosFromLatLng_(this.center_);\n    this.div_.style.top = pos.y + \"px\";\n    this.div_.style.left = pos.x + \"px\";\n  }\n};\n\n/**\n * Hides the icon.\n */\nClusterIcon.prototype.hide = function () {\n  if (this.div_) {\n    this.div_.style.display = \"none\";\n  }\n  this.visible_ = false;\n};\n\n/**\n * Positions and shows the icon.\n */\nClusterIcon.prototype.show = function () {\n  if (this.div_) {\n    var img = \"\";\n    // NOTE: values must be specified in px units\n    var bp = this.backgroundPosition_.split(\" \");\n    var spriteH = parseInt(bp[0].replace(/^\\s+|\\s+$/g, \"\"), 10);\n    var spriteV = parseInt(bp[1].replace(/^\\s+|\\s+$/g, \"\"), 10);\n    var pos = this.getPosFromLatLng_(this.center_);\n    this.div_.style.cssText = this.createCss(pos);\n    img = \"<img src='\" + this.url_ + \"' style='position: absolute; top: \" + spriteV + \"px; left: \" + spriteH + \"px; \";\n    if (!this.cluster_.getMarkerClusterer().enableRetinaIcons_) {\n      img += \"clip: rect(\" + -1 * spriteV + \"px, \" + (-1 * spriteH + this.width_) + \"px, \" + (-1 * spriteV + this.height_) + \"px, \" + -1 * spriteH + \"px);\";\n    }\n    img += \"'>\";\n    this.div_.innerHTML = img + \"<div style='\" + \"position: absolute;\" + \"top: \" + this.anchorText_[0] + \"px;\" + \"left: \" + this.anchorText_[1] + \"px;\" + \"color: \" + this.textColor_ + \";\" + \"font-size: \" + this.textSize_ + \"px;\" + \"font-family: \" + this.fontFamily_ + \";\" + \"font-weight: \" + this.fontWeight_ + \";\" + \"font-style: \" + this.fontStyle_ + \";\" + \"text-decoration: \" + this.textDecoration_ + \";\" + \"text-align: center;\" + \"width: \" + this.width_ + \"px;\" + \"line-height:\" + this.height_ + \"px;\" + \"'>\" + this.sums_.text + \"</div>\";\n    if (typeof this.sums_.title === \"undefined\" || this.sums_.title === \"\") {\n      this.div_.title = this.cluster_.getMarkerClusterer().getTitle();\n    } else {\n      this.div_.title = this.sums_.title;\n    }\n    this.div_.style.display = \"\";\n  }\n  this.visible_ = true;\n};\n\n/**\n * Sets the icon styles to the appropriate element in the styles array.\n *\n * @param {ClusterIconInfo} sums The icon label text and styles index.\n */\nClusterIcon.prototype.useStyle = function (sums) {\n  this.sums_ = sums;\n  var index = Math.max(0, sums.index - 1);\n  index = Math.min(this.styles_.length - 1, index);\n  var style = this.styles_[index];\n  this.url_ = style.url;\n  this.height_ = style.height;\n  this.width_ = style.width;\n  this.anchorText_ = style.anchorText || [0, 0];\n  this.anchorIcon_ = style.anchorIcon || [parseInt(this.height_ / 2, 10), parseInt(this.width_ / 2, 10)];\n  this.textColor_ = style.textColor || \"black\";\n  this.textSize_ = style.textSize || 11;\n  this.textDecoration_ = style.textDecoration || \"none\";\n  this.fontWeight_ = style.fontWeight || \"bold\";\n  this.fontStyle_ = style.fontStyle || \"normal\";\n  this.fontFamily_ = style.fontFamily || \"Arial,sans-serif\";\n  this.backgroundPosition_ = style.backgroundPosition || \"0 0\";\n};\n\n/**\n * Sets the position at which to center the icon.\n *\n * @param {google.maps.LatLng} center The latlng to set as the center.\n */\nClusterIcon.prototype.setCenter = function (center) {\n  this.center_ = center;\n};\n\n/**\n * Creates the cssText style parameter based on the position of the icon.\n *\n * @param {google.maps.Point} pos The position of the icon.\n * @return {string} The CSS style text.\n */\nClusterIcon.prototype.createCss = function (pos) {\n  var style = [];\n  style.push(\"cursor: pointer;\");\n  style.push(\"position: absolute; top: \" + pos.y + \"px; left: \" + pos.x + \"px;\");\n  style.push(\"width: \" + this.width_ + \"px; height: \" + this.height_ + \"px;\");\n  return style.join(\"\");\n};\n\n/**\n * Returns the position at which to place the DIV depending on the latlng.\n *\n * @param {google.maps.LatLng} latlng The position in latlng.\n * @return {google.maps.Point} The position in pixels.\n */\nClusterIcon.prototype.getPosFromLatLng_ = function (latlng) {\n  var pos = this.getProjection().fromLatLngToDivPixel(latlng);\n  pos.x -= this.anchorIcon_[1];\n  pos.y -= this.anchorIcon_[0];\n  pos.x = parseInt(pos.x, 10);\n  pos.y = parseInt(pos.y, 10);\n  return pos;\n};\n\n/**\n * Creates a single cluster that manages a group of proximate markers.\n *  Used internally, do not call this constructor directly.\n * @constructor\n * @param {MarkerClusterer} mc The <code>MarkerClusterer</code> object with which this\n *  cluster is associated.\n */\nfunction Cluster(mc) {\n  this.markerClusterer_ = mc;\n  this.map_ = mc.getMap();\n  this.gridSize_ = mc.getGridSize();\n  this.minClusterSize_ = mc.getMinimumClusterSize();\n  this.averageCenter_ = mc.getAverageCenter();\n  this.markers_ = [];\n  this.center_ = null;\n  this.bounds_ = null;\n  this.clusterIcon_ = new ClusterIcon(this, mc.getStyles());\n}\n\n/**\n * Returns the number of markers managed by the cluster. You can call this from\n * a <code>click</code>, <code>mouseover</code>, or <code>mouseout</code> event handler\n * for the <code>MarkerClusterer</code> object.\n *\n * @return {number} The number of markers in the cluster.\n */\nCluster.prototype.getSize = function () {\n  return this.markers_.length;\n};\n\n/**\n * Returns the array of markers managed by the cluster. You can call this from\n * a <code>click</code>, <code>mouseover</code>, or <code>mouseout</code> event handler\n * for the <code>MarkerClusterer</code> object.\n *\n * @return {Array} The array of markers in the cluster.\n */\nCluster.prototype.getMarkers = function () {\n  return this.markers_;\n};\n\n/**\n * Returns the center of the cluster. You can call this from\n * a <code>click</code>, <code>mouseover</code>, or <code>mouseout</code> event handler\n * for the <code>MarkerClusterer</code> object.\n *\n * @return {google.maps.LatLng} The center of the cluster.\n */\nCluster.prototype.getCenter = function () {\n  return this.center_;\n};\n\n/**\n * Returns the map with which the cluster is associated.\n *\n * @return {google.maps.Map} The map.\n * @ignore\n */\nCluster.prototype.getMap = function () {\n  return this.map_;\n};\n\n/**\n * Returns the <code>MarkerClusterer</code> object with which the cluster is associated.\n *\n * @return {MarkerClusterer} The associated marker clusterer.\n * @ignore\n */\nCluster.prototype.getMarkerClusterer = function () {\n  return this.markerClusterer_;\n};\n\n/**\n * Returns the bounds of the cluster.\n *\n * @return {google.maps.LatLngBounds} the cluster bounds.\n * @ignore\n */\nCluster.prototype.getBounds = function () {\n  var i;\n  var bounds = new google.maps.LatLngBounds(this.center_, this.center_);\n  var markers = this.getMarkers();\n  for (i = 0; i < markers.length; i++) {\n    bounds.extend(markers[i].getPosition());\n  }\n  return bounds;\n};\n\n/**\n * Removes the cluster from the map.\n *\n * @ignore\n */\nCluster.prototype.remove = function () {\n  this.clusterIcon_.setMap(null);\n  this.markers_ = [];\n  delete this.markers_;\n};\n\n/**\n * Adds a marker to the cluster.\n *\n * @param {google.maps.Marker} marker The marker to be added.\n * @return {boolean} True if the marker was added.\n * @ignore\n */\nCluster.prototype.addMarker = function (marker) {\n  var i;\n  var mCount;\n  var mz;\n  if (this.isMarkerAlreadyAdded_(marker)) {\n    return false;\n  }\n  if (!this.center_) {\n    this.center_ = marker.getPosition();\n    this.calculateBounds_();\n  } else {\n    if (this.averageCenter_) {\n      var l = this.markers_.length + 1;\n      var lat = (this.center_.lat() * (l - 1) + marker.getPosition().lat()) / l;\n      var lng = (this.center_.lng() * (l - 1) + marker.getPosition().lng()) / l;\n      this.center_ = new google.maps.LatLng(lat, lng);\n      this.calculateBounds_();\n    }\n  }\n  marker.isAdded = true;\n  this.markers_.push(marker);\n  mCount = this.markers_.length;\n  mz = this.markerClusterer_.getMaxZoom();\n  if (mz !== null && this.map_.getZoom() > mz) {\n    // Zoomed in past max zoom, so show the marker.\n    if (marker.getMap() !== this.map_) {\n      marker.setMap(this.map_);\n    }\n  } else if (mCount < this.minClusterSize_) {\n    // Min cluster size not reached so show the marker.\n    if (marker.getMap() !== this.map_) {\n      marker.setMap(this.map_);\n    }\n  } else if (mCount === this.minClusterSize_) {\n    // Hide the markers that were showing.\n    for (i = 0; i < mCount; i++) {\n      this.markers_[i].setMap(null);\n    }\n  } else {\n    marker.setMap(null);\n  }\n  this.updateIcon_();\n  return true;\n};\n\n/**\n * Determines if a marker lies within the cluster's bounds.\n *\n * @param {google.maps.Marker} marker The marker to check.\n * @return {boolean} True if the marker lies in the bounds.\n * @ignore\n */\nCluster.prototype.isMarkerInClusterBounds = function (marker) {\n  return this.bounds_.contains(marker.getPosition());\n};\n\n/**\n * Calculates the extended bounds of the cluster with the grid.\n */\nCluster.prototype.calculateBounds_ = function () {\n  var bounds = new google.maps.LatLngBounds(this.center_, this.center_);\n  this.bounds_ = this.markerClusterer_.getExtendedBounds(bounds);\n};\n\n/**\n * Updates the cluster icon.\n */\nCluster.prototype.updateIcon_ = function () {\n  var mCount = this.markers_.length;\n  var mz = this.markerClusterer_.getMaxZoom();\n  if (mz !== null && this.map_.getZoom() > mz) {\n    this.clusterIcon_.hide();\n    return;\n  }\n  if (mCount < this.minClusterSize_) {\n    // Min cluster size not yet reached.\n    this.clusterIcon_.hide();\n    return;\n  }\n  var numStyles = this.markerClusterer_.getStyles().length;\n  var sums = this.markerClusterer_.getCalculator()(this.markers_, numStyles);\n  this.clusterIcon_.setCenter(this.center_);\n  this.clusterIcon_.useStyle(sums);\n  this.clusterIcon_.show();\n};\n\n/**\n * Determines if a marker has already been added to the cluster.\n *\n * @param {google.maps.Marker} marker The marker to check.\n * @return {boolean} True if the marker has already been added.\n */\nCluster.prototype.isMarkerAlreadyAdded_ = function (marker) {\n  var i;\n  if (this.markers_.indexOf) {\n    return this.markers_.indexOf(marker) !== -1;\n  } else {\n    for (i = 0; i < this.markers_.length; i++) {\n      if (marker === this.markers_[i]) {\n        return true;\n      }\n    }\n  }\n  return false;\n};\n\n/**\n * @name MarkerClustererOptions\n * @class This class represents the optional parameter passed to\n *  the {@link MarkerClusterer} constructor.\n * @property {number} [gridSize=60] The grid size of a cluster in pixels. The grid is a square.\n * @property {number} [maxZoom=null] The maximum zoom level at which clustering is enabled or\n *  <code>null</code> if clustering is to be enabled at all zoom levels.\n * @property {boolean} [zoomOnClick=true] Whether to zoom the map when a cluster marker is\n *  clicked. You may want to set this to <code>false</code> if you have installed a handler\n *  for the <code>click</code> event and it deals with zooming on its own.\n * @property {boolean} [averageCenter=false] Whether the position of a cluster marker should be\n *  the average position of all markers in the cluster. If set to <code>false</code>, the\n *  cluster marker is positioned at the location of the first marker added to the cluster.\n * @property {number} [minimumClusterSize=2] The minimum number of markers needed in a cluster\n *  before the markers are hidden and a cluster marker appears.\n * @property {boolean} [ignoreHidden=false] Whether to ignore hidden markers in clusters. You\n *  may want to set this to <code>true</code> to ensure that hidden markers are not included\n *  in the marker count that appears on a cluster marker (this count is the value of the\n *  <code>text</code> property of the result returned by the default <code>calculator</code>).\n *  If set to <code>true</code> and you change the visibility of a marker being clustered, be\n *  sure to also call <code>MarkerClusterer.repaint()</code>.\n * @property {string} [title=\"\"] The tooltip to display when the mouse moves over a cluster\n *  marker. (Alternatively, you can use a custom <code>calculator</code> function to specify a\n *  different tooltip for each cluster marker.)\n * @property {function} [calculator=MarkerClusterer.CALCULATOR] The function used to determine\n *  the text to be displayed on a cluster marker and the index indicating which style to use\n *  for the cluster marker. The input parameters for the function are (1) the array of markers\n *  represented by a cluster marker and (2) the number of cluster icon styles. It returns a\n *  {@link ClusterIconInfo} object. The default <code>calculator</code> returns a\n *  <code>text</code> property which is the number of markers in the cluster and an\n *  <code>index</code> property which is one higher than the lowest integer such that\n *  <code>10^i</code> exceeds the number of markers in the cluster, or the size of the styles\n *  array, whichever is less. The <code>styles</code> array element used has an index of\n *  <code>index</code> minus 1. For example, the default <code>calculator</code> returns a\n *  <code>text</code> value of <code>\"125\"</code> and an <code>index</code> of <code>3</code>\n *  for a cluster icon representing 125 markers so the element used in the <code>styles</code>\n *  array is <code>2</code>. A <code>calculator</code> may also return a <code>title</code>\n *  property that contains the text of the tooltip to be used for the cluster marker. If\n *   <code>title</code> is not defined, the tooltip is set to the value of the <code>title</code>\n *   property for the MarkerClusterer.\n * @property {string} [clusterClass=\"cluster\"] The name of the CSS class defining general styles\n *  for the cluster markers. Use this class to define CSS styles that are not set up by the code\n *  that processes the <code>styles</code> array.\n * @property {Array} [styles] An array of {@link ClusterIconStyle} elements defining the styles\n *  of the cluster markers to be used. The element to be used to style a given cluster marker\n *  is determined by the function defined by the <code>calculator</code> property.\n *  The default is an array of {@link ClusterIconStyle} elements whose properties are derived\n *  from the values for <code>imagePath</code>, <code>imageExtension</code>, and\n *  <code>imageSizes</code>.\n * @property {boolean} [enableRetinaIcons=false] Whether to allow the use of cluster icons that\n * have sizes that are some multiple (typically double) of their actual display size. Icons such\n * as these look better when viewed on high-resolution monitors such as Apple's Retina displays.\n * Note: if this property is <code>true</code>, sprites cannot be used as cluster icons.\n * @property {number} [batchSize=MarkerClusterer.BATCH_SIZE] Set this property to the\n *  number of markers to be processed in a single batch when using a browser other than\n *  Internet Explorer (for Internet Explorer, use the batchSizeIE property instead).\n * @property {number} [batchSizeIE=MarkerClusterer.BATCH_SIZE_IE] When Internet Explorer is\n *  being used, markers are processed in several batches with a small delay inserted between\n *  each batch in an attempt to avoid Javascript timeout errors. Set this property to the\n *  number of markers to be processed in a single batch; select as high a number as you can\n *  without causing a timeout error in the browser. This number might need to be as low as 100\n *  if 15,000 markers are being managed, for example.\n * @property {string} [imagePath=MarkerClusterer.IMAGE_PATH]\n *  The full URL of the root name of the group of image files to use for cluster icons.\n *  The complete file name is of the form <code>imagePath</code>n.<code>imageExtension</code>\n *  where n is the image file number (1, 2, etc.).\n * @property {string} [imageExtension=MarkerClusterer.IMAGE_EXTENSION]\n *  The extension name for the cluster icon image files (e.g., <code>\"png\"</code> or\n *  <code>\"jpg\"</code>).\n * @property {Array} [imageSizes=MarkerClusterer.IMAGE_SIZES]\n *  An array of numbers containing the widths of the group of\n *  <code>imagePath</code>n.<code>imageExtension</code> image files.\n *  (The images are assumed to be square.)\n */\n/**\n * Creates a MarkerClusterer object with the options specified in {@link MarkerClustererOptions}.\n * @constructor\n * @extends google.maps.OverlayView\n * @param {google.maps.Map} map The Google map to attach to.\n * @param {Array.<google.maps.Marker>} [opt_markers] The markers to be added to the cluster.\n * @param {MarkerClustererOptions} [opt_options] The optional parameters.\n */\nfunction MarkerClusterer(map, opt_markers, opt_options) {\n  // MarkerClusterer implements google.maps.OverlayView interface. We use the\n  // extend function to extend MarkerClusterer with google.maps.OverlayView\n  // because it might not always be available when the code is defined so we\n  // look for it at the last possible moment. If it doesn't exist now then\n  // there is no point going ahead :)\n  this.extend(MarkerClusterer, google.maps.OverlayView);\n  opt_markers = opt_markers || [];\n  opt_options = opt_options || {};\n  this.markers_ = [];\n  this.clusters_ = [];\n  this.listeners_ = [];\n  this.activeMap_ = null;\n  this.ready_ = false;\n  this.gridSize_ = opt_options.gridSize || 60;\n  this.minClusterSize_ = opt_options.minimumClusterSize || 2;\n  this.maxZoom_ = opt_options.maxZoom || null;\n  this.styles_ = opt_options.styles || [];\n  this.title_ = opt_options.title || \"\";\n  this.zoomOnClick_ = true;\n  if (opt_options.zoomOnClick !== undefined) {\n    this.zoomOnClick_ = opt_options.zoomOnClick;\n  }\n  this.averageCenter_ = false;\n  if (opt_options.averageCenter !== undefined) {\n    this.averageCenter_ = opt_options.averageCenter;\n  }\n  this.ignoreHidden_ = false;\n  if (opt_options.ignoreHidden !== undefined) {\n    this.ignoreHidden_ = opt_options.ignoreHidden;\n  }\n  this.enableRetinaIcons_ = false;\n  if (opt_options.enableRetinaIcons !== undefined) {\n    this.enableRetinaIcons_ = opt_options.enableRetinaIcons;\n  }\n  this.imagePath_ = opt_options.imagePath || MarkerClusterer.IMAGE_PATH;\n  this.imageExtension_ = opt_options.imageExtension || MarkerClusterer.IMAGE_EXTENSION;\n  this.imageSizes_ = opt_options.imageSizes || MarkerClusterer.IMAGE_SIZES;\n  this.calculator_ = opt_options.calculator || MarkerClusterer.CALCULATOR;\n  this.batchSize_ = opt_options.batchSize || MarkerClusterer.BATCH_SIZE;\n  this.batchSizeIE_ = opt_options.batchSizeIE || MarkerClusterer.BATCH_SIZE_IE;\n  this.clusterClass_ = opt_options.clusterClass || \"cluster\";\n  if (navigator.userAgent.toLowerCase().indexOf(\"msie\") !== -1) {\n    // Try to avoid IE timeout when processing a huge number of markers:\n    this.batchSize_ = this.batchSizeIE_;\n  }\n  this.setupStyles_();\n  this.addMarkers(opt_markers, true);\n  this.setMap(map); // Note: this causes onAdd to be called\n}\n\n/**\n * Implementation of the onAdd interface method.\n * @ignore\n */\nMarkerClusterer.prototype.onAdd = function () {\n  var cMarkerClusterer = this;\n  this.activeMap_ = this.getMap();\n  this.ready_ = true;\n  this.repaint();\n\n  // Add the map event listeners\n  this.listeners_ = [google.maps.event.addListener(this.getMap(), \"zoom_changed\", function () {\n    cMarkerClusterer.resetViewport_(false);\n    // Workaround for this Google bug: when map is at level 0 and \"-\" of\n    // zoom slider is clicked, a \"zoom_changed\" event is fired even though\n    // the map doesn't zoom out any further. In this situation, no \"idle\"\n    // event is triggered so the cluster markers that have been removed\n    // do not get redrawn. Same goes for a zoom in at maxZoom.\n    if (this.getZoom() === (this.get(\"minZoom\") || 0) || this.getZoom() === this.get(\"maxZoom\")) {\n      google.maps.event.trigger(this, \"idle\");\n    }\n  }), google.maps.event.addListener(this.getMap(), \"idle\", function () {\n    cMarkerClusterer.redraw_();\n  })];\n};\n\n/**\n * Implementation of the onRemove interface method.\n * Removes map event listeners and all cluster icons from the DOM.\n * All managed markers are also put back on the map.\n * @ignore\n */\nMarkerClusterer.prototype.onRemove = function () {\n  var i;\n\n  // Put all the managed markers back on the map:\n  for (i = 0; i < this.markers_.length; i++) {\n    if (this.markers_[i].getMap() !== this.activeMap_) {\n      this.markers_[i].setMap(this.activeMap_);\n    }\n  }\n\n  // Remove all clusters:\n  for (i = 0; i < this.clusters_.length; i++) {\n    this.clusters_[i].remove();\n  }\n  this.clusters_ = [];\n\n  // Remove map event listeners:\n  for (i = 0; i < this.listeners_.length; i++) {\n    google.maps.event.removeListener(this.listeners_[i]);\n  }\n  this.listeners_ = [];\n  this.activeMap_ = null;\n  this.ready_ = false;\n};\n\n/**\n * Implementation of the draw interface method.\n * @ignore\n */\nMarkerClusterer.prototype.draw = function () {};\n\n/**\n * Sets up the styles object.\n */\nMarkerClusterer.prototype.setupStyles_ = function () {\n  var i, size;\n  if (this.styles_.length > 0) {\n    return;\n  }\n  for (i = 0; i < this.imageSizes_.length; i++) {\n    size = this.imageSizes_[i];\n    this.styles_.push({\n      url: this.imagePath_ + (i + 1) + \".\" + this.imageExtension_,\n      height: size,\n      width: size\n    });\n  }\n};\n\n/**\n *  Fits the map to the bounds of the markers managed by the clusterer.\n */\nMarkerClusterer.prototype.fitMapToMarkers = function () {\n  var i;\n  var markers = this.getMarkers();\n  var bounds = new google.maps.LatLngBounds();\n  for (i = 0; i < markers.length; i++) {\n    bounds.extend(markers[i].getPosition());\n  }\n  this.getMap().fitBounds(bounds);\n};\n\n/**\n * Returns the value of the <code>gridSize</code> property.\n *\n * @return {number} The grid size.\n */\nMarkerClusterer.prototype.getGridSize = function () {\n  return this.gridSize_;\n};\n\n/**\n * Sets the value of the <code>gridSize</code> property.\n *\n * @param {number} gridSize The grid size.\n */\nMarkerClusterer.prototype.setGridSize = function (gridSize) {\n  this.gridSize_ = gridSize;\n};\n\n/**\n * Returns the value of the <code>minimumClusterSize</code> property.\n *\n * @return {number} The minimum cluster size.\n */\nMarkerClusterer.prototype.getMinimumClusterSize = function () {\n  return this.minClusterSize_;\n};\n\n/**\n * Sets the value of the <code>minimumClusterSize</code> property.\n *\n * @param {number} minimumClusterSize The minimum cluster size.\n */\nMarkerClusterer.prototype.setMinimumClusterSize = function (minimumClusterSize) {\n  this.minClusterSize_ = minimumClusterSize;\n};\n\n/**\n *  Returns the value of the <code>maxZoom</code> property.\n *\n *  @return {number} The maximum zoom level.\n */\nMarkerClusterer.prototype.getMaxZoom = function () {\n  return this.maxZoom_;\n};\n\n/**\n *  Sets the value of the <code>maxZoom</code> property.\n *\n *  @param {number} maxZoom The maximum zoom level.\n */\nMarkerClusterer.prototype.setMaxZoom = function (maxZoom) {\n  this.maxZoom_ = maxZoom;\n};\n\n/**\n *  Returns the value of the <code>styles</code> property.\n *\n *  @return {Array} The array of styles defining the cluster markers to be used.\n */\nMarkerClusterer.prototype.getStyles = function () {\n  return this.styles_;\n};\n\n/**\n *  Sets the value of the <code>styles</code> property.\n *\n *  @param {Array.<ClusterIconStyle>} styles The array of styles to use.\n */\nMarkerClusterer.prototype.setStyles = function (styles) {\n  this.styles_ = styles;\n};\n\n/**\n * Returns the value of the <code>title</code> property.\n *\n * @return {string} The content of the title text.\n */\nMarkerClusterer.prototype.getTitle = function () {\n  return this.title_;\n};\n\n/**\n *  Sets the value of the <code>title</code> property.\n *\n *  @param {string} title The value of the title property.\n */\nMarkerClusterer.prototype.setTitle = function (title) {\n  this.title_ = title;\n};\n\n/**\n * Returns the value of the <code>zoomOnClick</code> property.\n *\n * @return {boolean} True if zoomOnClick property is set.\n */\nMarkerClusterer.prototype.getZoomOnClick = function () {\n  return this.zoomOnClick_;\n};\n\n/**\n *  Sets the value of the <code>zoomOnClick</code> property.\n *\n *  @param {boolean} zoomOnClick The value of the zoomOnClick property.\n */\nMarkerClusterer.prototype.setZoomOnClick = function (zoomOnClick) {\n  this.zoomOnClick_ = zoomOnClick;\n};\n\n/**\n * Returns the value of the <code>averageCenter</code> property.\n *\n * @return {boolean} True if averageCenter property is set.\n */\nMarkerClusterer.prototype.getAverageCenter = function () {\n  return this.averageCenter_;\n};\n\n/**\n *  Sets the value of the <code>averageCenter</code> property.\n *\n *  @param {boolean} averageCenter The value of the averageCenter property.\n */\nMarkerClusterer.prototype.setAverageCenter = function (averageCenter) {\n  this.averageCenter_ = averageCenter;\n};\n\n/**\n * Returns the value of the <code>ignoreHidden</code> property.\n *\n * @return {boolean} True if ignoreHidden property is set.\n */\nMarkerClusterer.prototype.getIgnoreHidden = function () {\n  return this.ignoreHidden_;\n};\n\n/**\n *  Sets the value of the <code>ignoreHidden</code> property.\n *\n *  @param {boolean} ignoreHidden The value of the ignoreHidden property.\n */\nMarkerClusterer.prototype.setIgnoreHidden = function (ignoreHidden) {\n  this.ignoreHidden_ = ignoreHidden;\n};\n\n/**\n * Returns the value of the <code>enableRetinaIcons</code> property.\n *\n * @return {boolean} True if enableRetinaIcons property is set.\n */\nMarkerClusterer.prototype.getEnableRetinaIcons = function () {\n  return this.enableRetinaIcons_;\n};\n\n/**\n *  Sets the value of the <code>enableRetinaIcons</code> property.\n *\n *  @param {boolean} enableRetinaIcons The value of the enableRetinaIcons property.\n */\nMarkerClusterer.prototype.setEnableRetinaIcons = function (enableRetinaIcons) {\n  this.enableRetinaIcons_ = enableRetinaIcons;\n};\n\n/**\n * Returns the value of the <code>imageExtension</code> property.\n *\n * @return {string} The value of the imageExtension property.\n */\nMarkerClusterer.prototype.getImageExtension = function () {\n  return this.imageExtension_;\n};\n\n/**\n *  Sets the value of the <code>imageExtension</code> property.\n *\n *  @param {string} imageExtension The value of the imageExtension property.\n */\nMarkerClusterer.prototype.setImageExtension = function (imageExtension) {\n  this.imageExtension_ = imageExtension;\n};\n\n/**\n * Returns the value of the <code>imagePath</code> property.\n *\n * @return {string} The value of the imagePath property.\n */\nMarkerClusterer.prototype.getImagePath = function () {\n  return this.imagePath_;\n};\n\n/**\n *  Sets the value of the <code>imagePath</code> property.\n *\n *  @param {string} imagePath The value of the imagePath property.\n */\nMarkerClusterer.prototype.setImagePath = function (imagePath) {\n  this.imagePath_ = imagePath;\n};\n\n/**\n * Returns the value of the <code>imageSizes</code> property.\n *\n * @return {Array} The value of the imageSizes property.\n */\nMarkerClusterer.prototype.getImageSizes = function () {\n  return this.imageSizes_;\n};\n\n/**\n *  Sets the value of the <code>imageSizes</code> property.\n *\n *  @param {Array} imageSizes The value of the imageSizes property.\n */\nMarkerClusterer.prototype.setImageSizes = function (imageSizes) {\n  this.imageSizes_ = imageSizes;\n};\n\n/**\n * Returns the value of the <code>calculator</code> property.\n *\n * @return {function} the value of the calculator property.\n */\nMarkerClusterer.prototype.getCalculator = function () {\n  return this.calculator_;\n};\n\n/**\n * Sets the value of the <code>calculator</code> property.\n *\n * @param {function(Array.<google.maps.Marker>, number)} calculator The value\n *  of the calculator property.\n */\nMarkerClusterer.prototype.setCalculator = function (calculator) {\n  this.calculator_ = calculator;\n};\n\n/**\n * Returns the value of the <code>batchSizeIE</code> property.\n *\n * @return {number} the value of the batchSizeIE property.\n */\nMarkerClusterer.prototype.getBatchSizeIE = function () {\n  return this.batchSizeIE_;\n};\n\n/**\n * Sets the value of the <code>batchSizeIE</code> property.\n *\n *  @param {number} batchSizeIE The value of the batchSizeIE property.\n */\nMarkerClusterer.prototype.setBatchSizeIE = function (batchSizeIE) {\n  this.batchSizeIE_ = batchSizeIE;\n};\n\n/**\n * Returns the value of the <code>clusterClass</code> property.\n *\n * @return {string} the value of the clusterClass property.\n */\nMarkerClusterer.prototype.getClusterClass = function () {\n  return this.clusterClass_;\n};\n\n/**\n * Sets the value of the <code>clusterClass</code> property.\n *\n *  @param {string} clusterClass The value of the clusterClass property.\n */\nMarkerClusterer.prototype.setClusterClass = function (clusterClass) {\n  this.clusterClass_ = clusterClass;\n};\n\n/**\n *  Returns the array of markers managed by the clusterer.\n *\n *  @return {Array} The array of markers managed by the clusterer.\n */\nMarkerClusterer.prototype.getMarkers = function () {\n  return this.markers_;\n};\n\n/**\n *  Returns the number of markers managed by the clusterer.\n *\n *  @return {number} The number of markers.\n */\nMarkerClusterer.prototype.getTotalMarkers = function () {\n  return this.markers_.length;\n};\n\n/**\n * Returns the current array of clusters formed by the clusterer.\n *\n * @return {Array} The array of clusters formed by the clusterer.\n */\nMarkerClusterer.prototype.getClusters = function () {\n  return this.clusters_;\n};\n\n/**\n * Returns the number of clusters formed by the clusterer.\n *\n * @return {number} The number of clusters formed by the clusterer.\n */\nMarkerClusterer.prototype.getTotalClusters = function () {\n  return this.clusters_.length;\n};\n\n/**\n * Adds a marker to the clusterer. The clusters are redrawn unless\n *  <code>opt_nodraw</code> is set to <code>true</code>.\n *\n * @param {google.maps.Marker} marker The marker to add.\n * @param {boolean} [opt_nodraw] Set to <code>true</code> to prevent redrawing.\n */\nMarkerClusterer.prototype.addMarker = function (marker, opt_nodraw) {\n  this.pushMarkerTo_(marker);\n  if (!opt_nodraw) {\n    this.redraw_();\n  }\n};\n\n/**\n * Adds an array of markers to the clusterer. The clusters are redrawn unless\n *  <code>opt_nodraw</code> is set to <code>true</code>.\n *\n * @param {Array.<google.maps.Marker>} markers The markers to add.\n * @param {boolean} [opt_nodraw] Set to <code>true</code> to prevent redrawing.\n */\nMarkerClusterer.prototype.addMarkers = function (markers, opt_nodraw) {\n  var key;\n  for (key in markers) {\n    if (markers.hasOwnProperty(key)) {\n      this.pushMarkerTo_(markers[key]);\n    }\n  }\n  if (!opt_nodraw) {\n    this.redraw_();\n  }\n};\n\n/**\n * Pushes a marker to the clusterer.\n *\n * @param {google.maps.Marker} marker The marker to add.\n */\nMarkerClusterer.prototype.pushMarkerTo_ = function (marker) {\n  // If the marker is draggable add a listener so we can update the clusters on the dragend:\n  if (marker.getDraggable()) {\n    var cMarkerClusterer = this;\n    google.maps.event.addListener(marker, \"dragend\", function () {\n      if (cMarkerClusterer.ready_) {\n        this.isAdded = false;\n        cMarkerClusterer.repaint();\n      }\n    });\n  }\n  marker.isAdded = false;\n  this.markers_.push(marker);\n};\n\n/**\n * Removes a marker from the cluster.  The clusters are redrawn unless\n *  <code>opt_nodraw</code> is set to <code>true</code>. Returns <code>true</code> if the\n *  marker was removed from the clusterer.\n *\n * @param {google.maps.Marker} marker The marker to remove.\n * @param {boolean} [opt_nodraw] Set to <code>true</code> to prevent redrawing.\n * @return {boolean} True if the marker was removed from the clusterer.\n */\nMarkerClusterer.prototype.removeMarker = function (marker, opt_nodraw) {\n  var removed = this.removeMarker_(marker);\n  if (!opt_nodraw && removed) {\n    this.repaint();\n  }\n  return removed;\n};\n\n/**\n * Removes an array of markers from the cluster. The clusters are redrawn unless\n *  <code>opt_nodraw</code> is set to <code>true</code>. Returns <code>true</code> if markers\n *  were removed from the clusterer.\n *\n * @param {Array.<google.maps.Marker>} markers The markers to remove.\n * @param {boolean} [opt_nodraw] Set to <code>true</code> to prevent redrawing.\n * @return {boolean} True if markers were removed from the clusterer.\n */\nMarkerClusterer.prototype.removeMarkers = function (markers, opt_nodraw) {\n  var i, r;\n  var removed = false;\n  for (i = 0; i < markers.length; i++) {\n    r = this.removeMarker_(markers[i]);\n    removed = removed || r;\n  }\n  if (!opt_nodraw && removed) {\n    this.repaint();\n  }\n  return removed;\n};\n\n/**\n * Removes a marker and returns true if removed, false if not.\n *\n * @param {google.maps.Marker} marker The marker to remove\n * @return {boolean} Whether the marker was removed or not\n */\nMarkerClusterer.prototype.removeMarker_ = function (marker) {\n  var i;\n  var index = -1;\n  if (this.markers_.indexOf) {\n    index = this.markers_.indexOf(marker);\n  } else {\n    for (i = 0; i < this.markers_.length; i++) {\n      if (marker === this.markers_[i]) {\n        index = i;\n        break;\n      }\n    }\n  }\n  if (index === -1) {\n    // Marker is not in our list of markers, so do nothing:\n    return false;\n  }\n  marker.setMap(null);\n  this.markers_.splice(index, 1); // Remove the marker from the list of managed markers\n  return true;\n};\n\n/**\n * Removes all clusters and markers from the map and also removes all markers\n *  managed by the clusterer.\n */\nMarkerClusterer.prototype.clearMarkers = function () {\n  this.resetViewport_(true);\n  this.markers_ = [];\n};\n\n/**\n * Recalculates and redraws all the marker clusters from scratch.\n *  Call this after changing any properties.\n */\nMarkerClusterer.prototype.repaint = function () {\n  var oldClusters = this.clusters_.slice();\n  this.clusters_ = [];\n  this.resetViewport_(false);\n  this.redraw_();\n\n  // Remove the old clusters.\n  // Do it in a timeout to prevent blinking effect.\n  setTimeout(function () {\n    var i;\n    for (i = 0; i < oldClusters.length; i++) {\n      oldClusters[i].remove();\n    }\n  }, 0);\n};\n\n/**\n * Returns the current bounds extended by the grid size.\n *\n * @param {google.maps.LatLngBounds} bounds The bounds to extend.\n * @return {google.maps.LatLngBounds} The extended bounds.\n * @ignore\n */\nMarkerClusterer.prototype.getExtendedBounds = function (bounds) {\n  var projection = this.getProjection();\n\n  // Turn the bounds into latlng.\n  var tr = new google.maps.LatLng(bounds.getNorthEast().lat(), bounds.getNorthEast().lng());\n  var bl = new google.maps.LatLng(bounds.getSouthWest().lat(), bounds.getSouthWest().lng());\n\n  // Convert the points to pixels and the extend out by the grid size.\n  var trPix = projection.fromLatLngToDivPixel(tr);\n  trPix.x += this.gridSize_;\n  trPix.y -= this.gridSize_;\n  var blPix = projection.fromLatLngToDivPixel(bl);\n  blPix.x -= this.gridSize_;\n  blPix.y += this.gridSize_;\n\n  // Convert the pixel points back to LatLng\n  var ne = projection.fromDivPixelToLatLng(trPix);\n  var sw = projection.fromDivPixelToLatLng(blPix);\n\n  // Extend the bounds to contain the new bounds.\n  bounds.extend(ne);\n  bounds.extend(sw);\n  return bounds;\n};\n\n/**\n * Redraws all the clusters.\n */\nMarkerClusterer.prototype.redraw_ = function () {\n  this.createClusters_(0);\n};\n\n/**\n * Removes all clusters from the map. The markers are also removed from the map\n *  if <code>opt_hide</code> is set to <code>true</code>.\n *\n * @param {boolean} [opt_hide] Set to <code>true</code> to also remove the markers\n *  from the map.\n */\nMarkerClusterer.prototype.resetViewport_ = function (opt_hide) {\n  var i, marker;\n  // Remove all the clusters\n  for (i = 0; i < this.clusters_.length; i++) {\n    this.clusters_[i].remove();\n  }\n  this.clusters_ = [];\n\n  // Reset the markers to not be added and to be removed from the map.\n  for (i = 0; i < this.markers_.length; i++) {\n    marker = this.markers_[i];\n    marker.isAdded = false;\n    if (opt_hide) {\n      marker.setMap(null);\n    }\n  }\n};\n\n/**\n * Calculates the distance between two latlng locations in km.\n *\n * @param {google.maps.LatLng} p1 The first lat lng point.\n * @param {google.maps.LatLng} p2 The second lat lng point.\n * @return {number} The distance between the two points in km.\n * @see http://www.movable-type.co.uk/scripts/latlong.html\n*/\nMarkerClusterer.prototype.distanceBetweenPoints_ = function (p1, p2) {\n  var R = 6371; // Radius of the Earth in km\n  var dLat = (p2.lat() - p1.lat()) * Math.PI / 180;\n  var dLon = (p2.lng() - p1.lng()) * Math.PI / 180;\n  var a = Math.sin(dLat / 2) * Math.sin(dLat / 2) + Math.cos(p1.lat() * Math.PI / 180) * Math.cos(p2.lat() * Math.PI / 180) * Math.sin(dLon / 2) * Math.sin(dLon / 2);\n  var c = 2 * Math.atan2(Math.sqrt(a), Math.sqrt(1 - a));\n  var d = R * c;\n  return d;\n};\n\n/**\n * Determines if a marker is contained in a bounds.\n *\n * @param {google.maps.Marker} marker The marker to check.\n * @param {google.maps.LatLngBounds} bounds The bounds to check against.\n * @return {boolean} True if the marker is in the bounds.\n */\nMarkerClusterer.prototype.isMarkerInBounds_ = function (marker, bounds) {\n  return bounds.contains(marker.getPosition());\n};\n\n/**\n * Adds a marker to a cluster, or creates a new cluster.\n *\n * @param {google.maps.Marker} marker The marker to add.\n */\nMarkerClusterer.prototype.addToClosestCluster_ = function (marker) {\n  var i, d, cluster, center;\n  var distance = 40000; // Some large number\n  var clusterToAddTo = null;\n  for (i = 0; i < this.clusters_.length; i++) {\n    cluster = this.clusters_[i];\n    center = cluster.getCenter();\n    if (center) {\n      d = this.distanceBetweenPoints_(center, marker.getPosition());\n      if (d < distance) {\n        distance = d;\n        clusterToAddTo = cluster;\n      }\n    }\n  }\n  if (clusterToAddTo && clusterToAddTo.isMarkerInClusterBounds(marker)) {\n    clusterToAddTo.addMarker(marker);\n  } else {\n    cluster = new Cluster(this);\n    cluster.addMarker(marker);\n    this.clusters_.push(cluster);\n  }\n};\n\n/**\n * Creates the clusters. This is done in batches to avoid timeout errors\n *  in some browsers when there is a huge number of markers.\n *\n * @param {number} iFirst The index of the first marker in the batch of\n *  markers to be added to clusters.\n */\nMarkerClusterer.prototype.createClusters_ = function (iFirst) {\n  var i, marker;\n  var mapBounds;\n  var cMarkerClusterer = this;\n  if (!this.ready_) {\n    return;\n  }\n\n  // Cancel previous batch processing if we're working on the first batch:\n  if (iFirst === 0) {\n    /**\n     * This event is fired when the <code>MarkerClusterer</code> begins\n     *  clustering markers.\n     * @name MarkerClusterer#clusteringbegin\n     * @param {MarkerClusterer} mc The MarkerClusterer whose markers are being clustered.\n     * @event\n     */\n    google.maps.event.trigger(this, \"clusteringbegin\", this);\n    if (typeof this.timerRefStatic !== \"undefined\") {\n      clearTimeout(this.timerRefStatic);\n      delete this.timerRefStatic;\n    }\n  }\n\n  // Get our current map view bounds.\n  // Create a new bounds object so we don't affect the map.\n  //\n  // See Comments 9 & 11 on Issue 3651 relating to this workaround for a Google Maps bug:\n  if (this.getMap().getZoom() > 3) {\n    mapBounds = new google.maps.LatLngBounds(this.getMap().getBounds().getSouthWest(), this.getMap().getBounds().getNorthEast());\n  } else {\n    mapBounds = new google.maps.LatLngBounds(new google.maps.LatLng(85.02070771743472, -178.48388434375), new google.maps.LatLng(-85.08136444384544, 178.00048865625));\n  }\n  var bounds = this.getExtendedBounds(mapBounds);\n  var iLast = Math.min(iFirst + this.batchSize_, this.markers_.length);\n  for (i = iFirst; i < iLast; i++) {\n    marker = this.markers_[i];\n    if (!marker.isAdded && this.isMarkerInBounds_(marker, bounds)) {\n      if (!this.ignoreHidden_ || this.ignoreHidden_ && marker.getVisible()) {\n        this.addToClosestCluster_(marker);\n      }\n    }\n  }\n  if (iLast < this.markers_.length) {\n    this.timerRefStatic = setTimeout(function () {\n      cMarkerClusterer.createClusters_(iLast);\n    }, 0);\n  } else {\n    delete this.timerRefStatic;\n\n    /**\n     * This event is fired when the <code>MarkerClusterer</code> stops\n     *  clustering markers.\n     * @name MarkerClusterer#clusteringend\n     * @param {MarkerClusterer} mc The MarkerClusterer whose markers are being clustered.\n     * @event\n     */\n    google.maps.event.trigger(this, \"clusteringend\", this);\n  }\n};\n\n/**\n * Extends an object's prototype by another's.\n *\n * @param {Object} obj1 The object to be extended.\n * @param {Object} obj2 The object to extend with.\n * @return {Object} The new extended object.\n * @ignore\n */\nMarkerClusterer.prototype.extend = function (obj1, obj2) {\n  return function (object) {\n    var property;\n    for (property in object.prototype) {\n      this.prototype[property] = object.prototype[property];\n    }\n    return this;\n  }.apply(obj1, [obj2]);\n};\n\n/**\n * The default function for determining the label text and style\n * for a cluster icon.\n *\n * @param {Array.<google.maps.Marker>} markers The array of markers represented by the cluster.\n * @param {number} numStyles The number of marker styles available.\n * @return {ClusterIconInfo} The information resource for the cluster.\n * @constant\n * @ignore\n */\nMarkerClusterer.CALCULATOR = function (markers, numStyles) {\n  var index = 0;\n  var title = \"\";\n  var count = markers.length.toString();\n  var dv = count;\n  while (dv !== 0) {\n    dv = parseInt(dv / 10, 10);\n    index++;\n  }\n  index = Math.min(index, numStyles);\n  return {\n    text: count,\n    index: index,\n    title: title\n  };\n};\n\n/**\n * The number of markers to process in one batch.\n *\n * @type {number}\n * @constant\n */\nMarkerClusterer.BATCH_SIZE = 2000;\n\n/**\n * The number of markers to process in one batch (IE only).\n *\n * @type {number}\n * @constant\n */\nMarkerClusterer.BATCH_SIZE_IE = 500;\n\n/**\n * The default root name for the marker cluster images.\n *\n * @type {string}\n * @constant\n */\nMarkerClusterer.IMAGE_PATH = \"https://raw.githubusercontent.com/googlemaps/v3-utility-library/master/markerclustererplus/images/m\";\n\n/**\n * The default extension name for the marker cluster images.\n *\n * @type {string}\n * @constant\n */\nMarkerClusterer.IMAGE_EXTENSION = \"png\";\n\n/**\n * The default array of sizes for the marker cluster images.\n *\n * @type {Array.<number>}\n * @constant\n */\nMarkerClusterer.IMAGE_SIZES = [53, 56, 66, 78, 90];\nmodule.exports = MarkerClusterer;","map":{"version":3,"names":["ClusterIcon","cluster","styles","getMarkerClusterer","extend","google","maps","OverlayView","cluster_","className_","getClusterClass","styles_","center_","div_","sums_","visible_","setMap","getMap","prototype","onAdd","cClusterIcon","cMouseDownInCluster","cDraggingMapByCluster","document","createElement","className","show","getPanes","overlayMouseTarget","appendChild","boundsChangedListener_","event","addListener","addDomListener","e","theBounds","mz","mc","trigger","getZoomOnClick","getMaxZoom","getBounds","fitBounds","setTimeout","getZoom","setZoom","cancelBubble","stopPropagation","onRemove","parentNode","hide","removeListener","clearInstanceListeners","removeChild","draw","pos","getPosFromLatLng_","style","top","y","left","x","display","img","bp","backgroundPosition_","split","spriteH","parseInt","replace","spriteV","cssText","createCss","url_","enableRetinaIcons_","width_","height_","innerHTML","anchorText_","textColor_","textSize_","fontFamily_","fontWeight_","fontStyle_","textDecoration_","text","title","getTitle","useStyle","sums","index","Math","max","min","length","url","height","width","anchorText","anchorIcon_","anchorIcon","textColor","textSize","textDecoration","fontWeight","fontStyle","fontFamily","backgroundPosition","setCenter","center","push","join","latlng","getProjection","fromLatLngToDivPixel","Cluster","markerClusterer_","map_","gridSize_","getGridSize","minClusterSize_","getMinimumClusterSize","averageCenter_","getAverageCenter","markers_","bounds_","clusterIcon_","getStyles","getSize","getMarkers","getCenter","i","bounds","LatLngBounds","markers","getPosition","remove","addMarker","marker","mCount","isMarkerAlreadyAdded_","calculateBounds_","l","lat","lng","LatLng","isAdded","updateIcon_","isMarkerInClusterBounds","contains","getExtendedBounds","numStyles","getCalculator","indexOf","MarkerClusterer","map","opt_markers","opt_options","clusters_","listeners_","activeMap_","ready_","gridSize","minimumClusterSize","maxZoom_","maxZoom","title_","zoomOnClick_","zoomOnClick","undefined","averageCenter","ignoreHidden_","ignoreHidden","enableRetinaIcons","imagePath_","imagePath","IMAGE_PATH","imageExtension_","imageExtension","IMAGE_EXTENSION","imageSizes_","imageSizes","IMAGE_SIZES","calculator_","calculator","CALCULATOR","batchSize_","batchSize","BATCH_SIZE","batchSizeIE_","batchSizeIE","BATCH_SIZE_IE","clusterClass_","clusterClass","navigator","userAgent","toLowerCase","setupStyles_","addMarkers","cMarkerClusterer","repaint","resetViewport_","get","redraw_","size","fitMapToMarkers","setGridSize","setMinimumClusterSize","setMaxZoom","setStyles","setTitle","setZoomOnClick","setAverageCenter","getIgnoreHidden","setIgnoreHidden","getEnableRetinaIcons","setEnableRetinaIcons","getImageExtension","setImageExtension","getImagePath","setImagePath","getImageSizes","setImageSizes","setCalculator","getBatchSizeIE","setBatchSizeIE","setClusterClass","getTotalMarkers","getClusters","getTotalClusters","opt_nodraw","pushMarkerTo_","key","hasOwnProperty","getDraggable","removeMarker","removed","removeMarker_","removeMarkers","r","splice","clearMarkers","oldClusters","slice","projection","tr","getNorthEast","bl","getSouthWest","trPix","blPix","ne","fromDivPixelToLatLng","sw","createClusters_","opt_hide","distanceBetweenPoints_","p1","p2","R","dLat","PI","dLon","a","sin","cos","c","atan2","sqrt","d","isMarkerInBounds_","addToClosestCluster_","distance","clusterToAddTo","iFirst","mapBounds","timerRefStatic","clearTimeout","iLast","getVisible","obj1","obj2","object","property","apply","count","toString","dv","module","exports"],"sources":["/Users/bookstore/Desktop/krmentor/material-dashboard-material-ui-v4/node_modules/marker-clusterer-plus/src/markerclusterer.js"],"sourcesContent":["/**\n * @name MarkerClustererPlus for Google Maps V3\n * @version 2.1.2 [May 28, 2014]\n * @author Gary Little\n * @fileoverview\n * The library creates and manages per-zoom-level clusters for large amounts of markers.\n * <p>\n * This is an enhanced V3 implementation of the\n * <a href=\"http://gmaps-utility-library-dev.googlecode.com/svn/tags/markerclusterer/\"\n * >V2 MarkerClusterer</a> by Xiaoxi Wu. It is based on the\n * <a href=\"http://google-maps-utility-library-v3.googlecode.com/svn/tags/markerclusterer/\"\n * >V3 MarkerClusterer</a> port by Luke Mahe. MarkerClustererPlus was created by Gary Little.\n * <p>\n * v2.0 release: MarkerClustererPlus v2.0 is backward compatible with MarkerClusterer v1.0. It\n *  adds support for the <code>ignoreHidden</code>, <code>title</code>, <code>batchSizeIE</code>,\n *  and <code>calculator</code> properties as well as support for four more events. It also allows\n *  greater control over the styling of the text that appears on the cluster marker. The\n *  documentation has been significantly improved and the overall code has been simplified and\n *  polished. Very large numbers of markers can now be managed without causing Javascript timeout\n *  errors on Internet Explorer. Note that the name of the <code>clusterclick</code> event has been\n *  deprecated. The new name is <code>click</code>, so please change your application code now.\n */\n\n/**\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\n\n/**\n * @name ClusterIconStyle\n * @class This class represents the object for values in the <code>styles</code> array passed\n *  to the {@link MarkerClusterer} constructor. The element in this array that is used to\n *  style the cluster icon is determined by calling the <code>calculator</code> function.\n *\n * @property {string} url The URL of the cluster icon image file. Required.\n * @property {number} height The display height (in pixels) of the cluster icon. Required.\n * @property {number} width The display width (in pixels) of the cluster icon. Required.\n * @property {Array} [anchorText] The position (in pixels) from the center of the cluster icon to\n *  where the text label is to be centered and drawn. The format is <code>[yoffset, xoffset]</code>\n *  where <code>yoffset</code> increases as you go down from center and <code>xoffset</code>\n *  increases to the right of center. The default is <code>[0, 0]</code>.\n * @property {Array} [anchorIcon] The anchor position (in pixels) of the cluster icon. This is the\n *  spot on the cluster icon that is to be aligned with the cluster position. The format is\n *  <code>[yoffset, xoffset]</code> where <code>yoffset</code> increases as you go down and\n *  <code>xoffset</code> increases to the right of the top-left corner of the icon. The default\n *  anchor position is the center of the cluster icon.\n * @property {string} [textColor=\"black\"] The color of the label text shown on the\n *  cluster icon.\n * @property {number} [textSize=11] The size (in pixels) of the label text shown on the\n *  cluster icon.\n * @property {string} [textDecoration=\"none\"] The value of the CSS <code>text-decoration</code>\n *  property for the label text shown on the cluster icon.\n * @property {string} [fontWeight=\"bold\"] The value of the CSS <code>font-weight</code>\n *  property for the label text shown on the cluster icon.\n * @property {string} [fontStyle=\"normal\"] The value of the CSS <code>font-style</code>\n *  property for the label text shown on the cluster icon.\n * @property {string} [fontFamily=\"Arial,sans-serif\"] The value of the CSS <code>font-family</code>\n *  property for the label text shown on the cluster icon.\n * @property {string} [backgroundPosition=\"0 0\"] The position of the cluster icon image\n *  within the image defined by <code>url</code>. The format is <code>\"xpos ypos\"</code>\n *  (the same format as for the CSS <code>background-position</code> property). You must set\n *  this property appropriately when the image defined by <code>url</code> represents a sprite\n *  containing multiple images. Note that the position <i>must</i> be specified in px units.\n */\n/**\n * @name ClusterIconInfo\n * @class This class is an object containing general information about a cluster icon. This is\n *  the object that a <code>calculator</code> function returns.\n *\n * @property {string} text The text of the label to be shown on the cluster icon.\n * @property {number} index The index plus 1 of the element in the <code>styles</code>\n *  array to be used to style the cluster icon.\n * @property {string} title The tooltip to display when the mouse moves over the cluster icon.\n *  If this value is <code>undefined</code> or <code>\"\"</code>, <code>title</code> is set to the\n *  value of the <code>title</code> property passed to the MarkerClusterer.\n */\n/**\n * A cluster icon.\n *\n * @constructor\n * @extends google.maps.OverlayView\n * @param {Cluster} cluster The cluster with which the icon is to be associated.\n * @param {Array} [styles] An array of {@link ClusterIconStyle} defining the cluster icons\n *  to use for various cluster sizes.\n * @private\n */\nfunction ClusterIcon(cluster, styles) {\n  cluster.getMarkerClusterer().extend(ClusterIcon, google.maps.OverlayView);\n\n  this.cluster_ = cluster;\n  this.className_ = cluster.getMarkerClusterer().getClusterClass();\n  this.styles_ = styles;\n  this.center_ = null;\n  this.div_ = null;\n  this.sums_ = null;\n  this.visible_ = false;\n\n  this.setMap(cluster.getMap()); // Note: this causes onAdd to be called\n}\n\n\n/**\n * Adds the icon to the DOM.\n */\nClusterIcon.prototype.onAdd = function () {\n  var cClusterIcon = this;\n  var cMouseDownInCluster;\n  var cDraggingMapByCluster;\n\n  this.div_ = document.createElement(\"div\");\n  this.div_.className = this.className_;\n  if (this.visible_) {\n    this.show();\n  }\n\n  this.getPanes().overlayMouseTarget.appendChild(this.div_);\n\n  // Fix for Issue 157\n  this.boundsChangedListener_ = google.maps.event.addListener(this.getMap(), \"bounds_changed\", function () {\n    cDraggingMapByCluster = cMouseDownInCluster;\n  });\n\n  google.maps.event.addDomListener(this.div_, \"mousedown\", function () {\n    cMouseDownInCluster = true;\n    cDraggingMapByCluster = false;\n  });\n\n  google.maps.event.addDomListener(this.div_, \"click\", function (e) {\n    cMouseDownInCluster = false;\n    if (!cDraggingMapByCluster) {\n      var theBounds;\n      var mz;\n      var mc = cClusterIcon.cluster_.getMarkerClusterer();\n      /**\n       * This event is fired when a cluster marker is clicked.\n       * @name MarkerClusterer#click\n       * @param {Cluster} c The cluster that was clicked.\n       * @event\n       */\n      google.maps.event.trigger(mc, \"click\", cClusterIcon.cluster_);\n      google.maps.event.trigger(mc, \"clusterclick\", cClusterIcon.cluster_); // deprecated name\n\n      // The default click handler follows. Disable it by setting\n      // the zoomOnClick property to false.\n      if (mc.getZoomOnClick()) {\n        // Zoom into the cluster.\n        mz = mc.getMaxZoom();\n        theBounds = cClusterIcon.cluster_.getBounds();\n        mc.getMap().fitBounds(theBounds);\n        // There is a fix for Issue 170 here:\n        setTimeout(function () {\n          mc.getMap().fitBounds(theBounds);\n          // Don't zoom beyond the max zoom level\n          if (mz !== null && (mc.getMap().getZoom() > mz)) {\n            mc.getMap().setZoom(mz + 1);\n          }\n        }, 100);\n      }\n\n      // Prevent event propagation to the map:\n      e.cancelBubble = true;\n      if (e.stopPropagation) {\n        e.stopPropagation();\n      }\n    }\n  });\n\n  google.maps.event.addDomListener(this.div_, \"mouseover\", function () {\n    var mc = cClusterIcon.cluster_.getMarkerClusterer();\n    /**\n     * This event is fired when the mouse moves over a cluster marker.\n     * @name MarkerClusterer#mouseover\n     * @param {Cluster} c The cluster that the mouse moved over.\n     * @event\n     */\n    google.maps.event.trigger(mc, \"mouseover\", cClusterIcon.cluster_);\n  });\n\n  google.maps.event.addDomListener(this.div_, \"mouseout\", function () {\n    var mc = cClusterIcon.cluster_.getMarkerClusterer();\n    /**\n     * This event is fired when the mouse moves out of a cluster marker.\n     * @name MarkerClusterer#mouseout\n     * @param {Cluster} c The cluster that the mouse moved out of.\n     * @event\n     */\n    google.maps.event.trigger(mc, \"mouseout\", cClusterIcon.cluster_);\n  });\n};\n\n\n/**\n * Removes the icon from the DOM.\n */\nClusterIcon.prototype.onRemove = function () {\n  if (this.div_ && this.div_.parentNode) {\n    this.hide();\n    google.maps.event.removeListener(this.boundsChangedListener_);\n    google.maps.event.clearInstanceListeners(this.div_);\n    this.div_.parentNode.removeChild(this.div_);\n    this.div_ = null;\n  }\n};\n\n\n/**\n * Draws the icon.\n */\nClusterIcon.prototype.draw = function () {\n  if (this.visible_) {\n    var pos = this.getPosFromLatLng_(this.center_);\n    this.div_.style.top = pos.y + \"px\";\n    this.div_.style.left = pos.x + \"px\";\n  }\n};\n\n\n/**\n * Hides the icon.\n */\nClusterIcon.prototype.hide = function () {\n  if (this.div_) {\n    this.div_.style.display = \"none\";\n  }\n  this.visible_ = false;\n};\n\n\n/**\n * Positions and shows the icon.\n */\nClusterIcon.prototype.show = function () {\n  if (this.div_) {\n    var img = \"\";\n    // NOTE: values must be specified in px units\n    var bp = this.backgroundPosition_.split(\" \");\n    var spriteH = parseInt(bp[0].replace(/^\\s+|\\s+$/g, \"\"), 10);\n    var spriteV = parseInt(bp[1].replace(/^\\s+|\\s+$/g, \"\"), 10);\n    var pos = this.getPosFromLatLng_(this.center_);\n    this.div_.style.cssText = this.createCss(pos);\n    img = \"<img src='\" + this.url_ + \"' style='position: absolute; top: \" + spriteV + \"px; left: \" + spriteH + \"px; \";\n    if (!this.cluster_.getMarkerClusterer().enableRetinaIcons_) {\n      img += \"clip: rect(\" + (-1 * spriteV) + \"px, \" + ((-1 * spriteH) + this.width_) + \"px, \" +\n          ((-1 * spriteV) + this.height_) + \"px, \" + (-1 * spriteH) + \"px);\";\n    }\n    img += \"'>\";\n    this.div_.innerHTML = img + \"<div style='\" +\n        \"position: absolute;\" +\n        \"top: \" + this.anchorText_[0] + \"px;\" +\n        \"left: \" + this.anchorText_[1] + \"px;\" +\n        \"color: \" + this.textColor_ + \";\" +\n        \"font-size: \" + this.textSize_ + \"px;\" +\n        \"font-family: \" + this.fontFamily_ + \";\" +\n        \"font-weight: \" + this.fontWeight_ + \";\" +\n        \"font-style: \" + this.fontStyle_ + \";\" +\n        \"text-decoration: \" + this.textDecoration_ + \";\" +\n        \"text-align: center;\" +\n        \"width: \" + this.width_ + \"px;\" +\n        \"line-height:\" + this.height_ + \"px;\" +\n        \"'>\" + this.sums_.text + \"</div>\";\n    if (typeof this.sums_.title === \"undefined\" || this.sums_.title === \"\") {\n      this.div_.title = this.cluster_.getMarkerClusterer().getTitle();\n    } else {\n      this.div_.title = this.sums_.title;\n    }\n    this.div_.style.display = \"\";\n  }\n  this.visible_ = true;\n};\n\n\n/**\n * Sets the icon styles to the appropriate element in the styles array.\n *\n * @param {ClusterIconInfo} sums The icon label text and styles index.\n */\nClusterIcon.prototype.useStyle = function (sums) {\n  this.sums_ = sums;\n  var index = Math.max(0, sums.index - 1);\n  index = Math.min(this.styles_.length - 1, index);\n  var style = this.styles_[index];\n  this.url_ = style.url;\n  this.height_ = style.height;\n  this.width_ = style.width;\n  this.anchorText_ = style.anchorText || [0, 0];\n  this.anchorIcon_ = style.anchorIcon || [parseInt(this.height_ / 2, 10), parseInt(this.width_ / 2, 10)];\n  this.textColor_ = style.textColor || \"black\";\n  this.textSize_ = style.textSize || 11;\n  this.textDecoration_ = style.textDecoration || \"none\";\n  this.fontWeight_ = style.fontWeight || \"bold\";\n  this.fontStyle_ = style.fontStyle || \"normal\";\n  this.fontFamily_ = style.fontFamily || \"Arial,sans-serif\";\n  this.backgroundPosition_ = style.backgroundPosition || \"0 0\";\n};\n\n\n/**\n * Sets the position at which to center the icon.\n *\n * @param {google.maps.LatLng} center The latlng to set as the center.\n */\nClusterIcon.prototype.setCenter = function (center) {\n  this.center_ = center;\n};\n\n\n/**\n * Creates the cssText style parameter based on the position of the icon.\n *\n * @param {google.maps.Point} pos The position of the icon.\n * @return {string} The CSS style text.\n */\nClusterIcon.prototype.createCss = function (pos) {\n  var style = [];\n  style.push(\"cursor: pointer;\");\n  style.push(\"position: absolute; top: \" + pos.y + \"px; left: \" + pos.x + \"px;\");\n  style.push(\"width: \" + this.width_ + \"px; height: \" + this.height_ + \"px;\");\n  return style.join(\"\");\n};\n\n\n/**\n * Returns the position at which to place the DIV depending on the latlng.\n *\n * @param {google.maps.LatLng} latlng The position in latlng.\n * @return {google.maps.Point} The position in pixels.\n */\nClusterIcon.prototype.getPosFromLatLng_ = function (latlng) {\n  var pos = this.getProjection().fromLatLngToDivPixel(latlng);\n  pos.x -= this.anchorIcon_[1];\n  pos.y -= this.anchorIcon_[0];\n  pos.x = parseInt(pos.x, 10);\n  pos.y = parseInt(pos.y, 10);\n  return pos;\n};\n\n\n/**\n * Creates a single cluster that manages a group of proximate markers.\n *  Used internally, do not call this constructor directly.\n * @constructor\n * @param {MarkerClusterer} mc The <code>MarkerClusterer</code> object with which this\n *  cluster is associated.\n */\nfunction Cluster(mc) {\n  this.markerClusterer_ = mc;\n  this.map_ = mc.getMap();\n  this.gridSize_ = mc.getGridSize();\n  this.minClusterSize_ = mc.getMinimumClusterSize();\n  this.averageCenter_ = mc.getAverageCenter();\n  this.markers_ = [];\n  this.center_ = null;\n  this.bounds_ = null;\n  this.clusterIcon_ = new ClusterIcon(this, mc.getStyles());\n}\n\n\n/**\n * Returns the number of markers managed by the cluster. You can call this from\n * a <code>click</code>, <code>mouseover</code>, or <code>mouseout</code> event handler\n * for the <code>MarkerClusterer</code> object.\n *\n * @return {number} The number of markers in the cluster.\n */\nCluster.prototype.getSize = function () {\n  return this.markers_.length;\n};\n\n\n/**\n * Returns the array of markers managed by the cluster. You can call this from\n * a <code>click</code>, <code>mouseover</code>, or <code>mouseout</code> event handler\n * for the <code>MarkerClusterer</code> object.\n *\n * @return {Array} The array of markers in the cluster.\n */\nCluster.prototype.getMarkers = function () {\n  return this.markers_;\n};\n\n\n/**\n * Returns the center of the cluster. You can call this from\n * a <code>click</code>, <code>mouseover</code>, or <code>mouseout</code> event handler\n * for the <code>MarkerClusterer</code> object.\n *\n * @return {google.maps.LatLng} The center of the cluster.\n */\nCluster.prototype.getCenter = function () {\n  return this.center_;\n};\n\n\n/**\n * Returns the map with which the cluster is associated.\n *\n * @return {google.maps.Map} The map.\n * @ignore\n */\nCluster.prototype.getMap = function () {\n  return this.map_;\n};\n\n\n/**\n * Returns the <code>MarkerClusterer</code> object with which the cluster is associated.\n *\n * @return {MarkerClusterer} The associated marker clusterer.\n * @ignore\n */\nCluster.prototype.getMarkerClusterer = function () {\n  return this.markerClusterer_;\n};\n\n\n/**\n * Returns the bounds of the cluster.\n *\n * @return {google.maps.LatLngBounds} the cluster bounds.\n * @ignore\n */\nCluster.prototype.getBounds = function () {\n  var i;\n  var bounds = new google.maps.LatLngBounds(this.center_, this.center_);\n  var markers = this.getMarkers();\n  for (i = 0; i < markers.length; i++) {\n    bounds.extend(markers[i].getPosition());\n  }\n  return bounds;\n};\n\n\n/**\n * Removes the cluster from the map.\n *\n * @ignore\n */\nCluster.prototype.remove = function () {\n  this.clusterIcon_.setMap(null);\n  this.markers_ = [];\n  delete this.markers_;\n};\n\n\n/**\n * Adds a marker to the cluster.\n *\n * @param {google.maps.Marker} marker The marker to be added.\n * @return {boolean} True if the marker was added.\n * @ignore\n */\nCluster.prototype.addMarker = function (marker) {\n  var i;\n  var mCount;\n  var mz;\n\n  if (this.isMarkerAlreadyAdded_(marker)) {\n    return false;\n  }\n\n  if (!this.center_) {\n    this.center_ = marker.getPosition();\n    this.calculateBounds_();\n  } else {\n    if (this.averageCenter_) {\n      var l = this.markers_.length + 1;\n      var lat = (this.center_.lat() * (l - 1) + marker.getPosition().lat()) / l;\n      var lng = (this.center_.lng() * (l - 1) + marker.getPosition().lng()) / l;\n      this.center_ = new google.maps.LatLng(lat, lng);\n      this.calculateBounds_();\n    }\n  }\n\n  marker.isAdded = true;\n  this.markers_.push(marker);\n\n  mCount = this.markers_.length;\n  mz = this.markerClusterer_.getMaxZoom();\n  if (mz !== null && this.map_.getZoom() > mz) {\n    // Zoomed in past max zoom, so show the marker.\n    if (marker.getMap() !== this.map_) {\n      marker.setMap(this.map_);\n    }\n  } else if (mCount < this.minClusterSize_) {\n    // Min cluster size not reached so show the marker.\n    if (marker.getMap() !== this.map_) {\n      marker.setMap(this.map_);\n    }\n  } else if (mCount === this.minClusterSize_) {\n    // Hide the markers that were showing.\n    for (i = 0; i < mCount; i++) {\n      this.markers_[i].setMap(null);\n    }\n  } else {\n    marker.setMap(null);\n  }\n\n  this.updateIcon_();\n  return true;\n};\n\n\n/**\n * Determines if a marker lies within the cluster's bounds.\n *\n * @param {google.maps.Marker} marker The marker to check.\n * @return {boolean} True if the marker lies in the bounds.\n * @ignore\n */\nCluster.prototype.isMarkerInClusterBounds = function (marker) {\n  return this.bounds_.contains(marker.getPosition());\n};\n\n\n/**\n * Calculates the extended bounds of the cluster with the grid.\n */\nCluster.prototype.calculateBounds_ = function () {\n  var bounds = new google.maps.LatLngBounds(this.center_, this.center_);\n  this.bounds_ = this.markerClusterer_.getExtendedBounds(bounds);\n};\n\n\n/**\n * Updates the cluster icon.\n */\nCluster.prototype.updateIcon_ = function () {\n  var mCount = this.markers_.length;\n  var mz = this.markerClusterer_.getMaxZoom();\n\n  if (mz !== null && this.map_.getZoom() > mz) {\n    this.clusterIcon_.hide();\n    return;\n  }\n\n  if (mCount < this.minClusterSize_) {\n    // Min cluster size not yet reached.\n    this.clusterIcon_.hide();\n    return;\n  }\n\n  var numStyles = this.markerClusterer_.getStyles().length;\n  var sums = this.markerClusterer_.getCalculator()(this.markers_, numStyles);\n  this.clusterIcon_.setCenter(this.center_);\n  this.clusterIcon_.useStyle(sums);\n  this.clusterIcon_.show();\n};\n\n\n/**\n * Determines if a marker has already been added to the cluster.\n *\n * @param {google.maps.Marker} marker The marker to check.\n * @return {boolean} True if the marker has already been added.\n */\nCluster.prototype.isMarkerAlreadyAdded_ = function (marker) {\n  var i;\n  if (this.markers_.indexOf) {\n    return this.markers_.indexOf(marker) !== -1;\n  } else {\n    for (i = 0; i < this.markers_.length; i++) {\n      if (marker === this.markers_[i]) {\n        return true;\n      }\n    }\n  }\n  return false;\n};\n\n\n/**\n * @name MarkerClustererOptions\n * @class This class represents the optional parameter passed to\n *  the {@link MarkerClusterer} constructor.\n * @property {number} [gridSize=60] The grid size of a cluster in pixels. The grid is a square.\n * @property {number} [maxZoom=null] The maximum zoom level at which clustering is enabled or\n *  <code>null</code> if clustering is to be enabled at all zoom levels.\n * @property {boolean} [zoomOnClick=true] Whether to zoom the map when a cluster marker is\n *  clicked. You may want to set this to <code>false</code> if you have installed a handler\n *  for the <code>click</code> event and it deals with zooming on its own.\n * @property {boolean} [averageCenter=false] Whether the position of a cluster marker should be\n *  the average position of all markers in the cluster. If set to <code>false</code>, the\n *  cluster marker is positioned at the location of the first marker added to the cluster.\n * @property {number} [minimumClusterSize=2] The minimum number of markers needed in a cluster\n *  before the markers are hidden and a cluster marker appears.\n * @property {boolean} [ignoreHidden=false] Whether to ignore hidden markers in clusters. You\n *  may want to set this to <code>true</code> to ensure that hidden markers are not included\n *  in the marker count that appears on a cluster marker (this count is the value of the\n *  <code>text</code> property of the result returned by the default <code>calculator</code>).\n *  If set to <code>true</code> and you change the visibility of a marker being clustered, be\n *  sure to also call <code>MarkerClusterer.repaint()</code>.\n * @property {string} [title=\"\"] The tooltip to display when the mouse moves over a cluster\n *  marker. (Alternatively, you can use a custom <code>calculator</code> function to specify a\n *  different tooltip for each cluster marker.)\n * @property {function} [calculator=MarkerClusterer.CALCULATOR] The function used to determine\n *  the text to be displayed on a cluster marker and the index indicating which style to use\n *  for the cluster marker. The input parameters for the function are (1) the array of markers\n *  represented by a cluster marker and (2) the number of cluster icon styles. It returns a\n *  {@link ClusterIconInfo} object. The default <code>calculator</code> returns a\n *  <code>text</code> property which is the number of markers in the cluster and an\n *  <code>index</code> property which is one higher than the lowest integer such that\n *  <code>10^i</code> exceeds the number of markers in the cluster, or the size of the styles\n *  array, whichever is less. The <code>styles</code> array element used has an index of\n *  <code>index</code> minus 1. For example, the default <code>calculator</code> returns a\n *  <code>text</code> value of <code>\"125\"</code> and an <code>index</code> of <code>3</code>\n *  for a cluster icon representing 125 markers so the element used in the <code>styles</code>\n *  array is <code>2</code>. A <code>calculator</code> may also return a <code>title</code>\n *  property that contains the text of the tooltip to be used for the cluster marker. If\n *   <code>title</code> is not defined, the tooltip is set to the value of the <code>title</code>\n *   property for the MarkerClusterer.\n * @property {string} [clusterClass=\"cluster\"] The name of the CSS class defining general styles\n *  for the cluster markers. Use this class to define CSS styles that are not set up by the code\n *  that processes the <code>styles</code> array.\n * @property {Array} [styles] An array of {@link ClusterIconStyle} elements defining the styles\n *  of the cluster markers to be used. The element to be used to style a given cluster marker\n *  is determined by the function defined by the <code>calculator</code> property.\n *  The default is an array of {@link ClusterIconStyle} elements whose properties are derived\n *  from the values for <code>imagePath</code>, <code>imageExtension</code>, and\n *  <code>imageSizes</code>.\n * @property {boolean} [enableRetinaIcons=false] Whether to allow the use of cluster icons that\n * have sizes that are some multiple (typically double) of their actual display size. Icons such\n * as these look better when viewed on high-resolution monitors such as Apple's Retina displays.\n * Note: if this property is <code>true</code>, sprites cannot be used as cluster icons.\n * @property {number} [batchSize=MarkerClusterer.BATCH_SIZE] Set this property to the\n *  number of markers to be processed in a single batch when using a browser other than\n *  Internet Explorer (for Internet Explorer, use the batchSizeIE property instead).\n * @property {number} [batchSizeIE=MarkerClusterer.BATCH_SIZE_IE] When Internet Explorer is\n *  being used, markers are processed in several batches with a small delay inserted between\n *  each batch in an attempt to avoid Javascript timeout errors. Set this property to the\n *  number of markers to be processed in a single batch; select as high a number as you can\n *  without causing a timeout error in the browser. This number might need to be as low as 100\n *  if 15,000 markers are being managed, for example.\n * @property {string} [imagePath=MarkerClusterer.IMAGE_PATH]\n *  The full URL of the root name of the group of image files to use for cluster icons.\n *  The complete file name is of the form <code>imagePath</code>n.<code>imageExtension</code>\n *  where n is the image file number (1, 2, etc.).\n * @property {string} [imageExtension=MarkerClusterer.IMAGE_EXTENSION]\n *  The extension name for the cluster icon image files (e.g., <code>\"png\"</code> or\n *  <code>\"jpg\"</code>).\n * @property {Array} [imageSizes=MarkerClusterer.IMAGE_SIZES]\n *  An array of numbers containing the widths of the group of\n *  <code>imagePath</code>n.<code>imageExtension</code> image files.\n *  (The images are assumed to be square.)\n */\n/**\n * Creates a MarkerClusterer object with the options specified in {@link MarkerClustererOptions}.\n * @constructor\n * @extends google.maps.OverlayView\n * @param {google.maps.Map} map The Google map to attach to.\n * @param {Array.<google.maps.Marker>} [opt_markers] The markers to be added to the cluster.\n * @param {MarkerClustererOptions} [opt_options] The optional parameters.\n */\nfunction MarkerClusterer(map, opt_markers, opt_options) {\n  // MarkerClusterer implements google.maps.OverlayView interface. We use the\n  // extend function to extend MarkerClusterer with google.maps.OverlayView\n  // because it might not always be available when the code is defined so we\n  // look for it at the last possible moment. If it doesn't exist now then\n  // there is no point going ahead :)\n  this.extend(MarkerClusterer, google.maps.OverlayView);\n\n  opt_markers = opt_markers || [];\n  opt_options = opt_options || {};\n\n  this.markers_ = [];\n  this.clusters_ = [];\n  this.listeners_ = [];\n  this.activeMap_ = null;\n  this.ready_ = false;\n\n  this.gridSize_ = opt_options.gridSize || 60;\n  this.minClusterSize_ = opt_options.minimumClusterSize || 2;\n  this.maxZoom_ = opt_options.maxZoom || null;\n  this.styles_ = opt_options.styles || [];\n  this.title_ = opt_options.title || \"\";\n  this.zoomOnClick_ = true;\n  if (opt_options.zoomOnClick !== undefined) {\n    this.zoomOnClick_ = opt_options.zoomOnClick;\n  }\n  this.averageCenter_ = false;\n  if (opt_options.averageCenter !== undefined) {\n    this.averageCenter_ = opt_options.averageCenter;\n  }\n  this.ignoreHidden_ = false;\n  if (opt_options.ignoreHidden !== undefined) {\n    this.ignoreHidden_ = opt_options.ignoreHidden;\n  }\n  this.enableRetinaIcons_ = false;\n  if (opt_options.enableRetinaIcons !== undefined) {\n    this.enableRetinaIcons_ = opt_options.enableRetinaIcons;\n  }\n  this.imagePath_ = opt_options.imagePath || MarkerClusterer.IMAGE_PATH;\n  this.imageExtension_ = opt_options.imageExtension || MarkerClusterer.IMAGE_EXTENSION;\n  this.imageSizes_ = opt_options.imageSizes || MarkerClusterer.IMAGE_SIZES;\n  this.calculator_ = opt_options.calculator || MarkerClusterer.CALCULATOR;\n  this.batchSize_ = opt_options.batchSize || MarkerClusterer.BATCH_SIZE;\n  this.batchSizeIE_ = opt_options.batchSizeIE || MarkerClusterer.BATCH_SIZE_IE;\n  this.clusterClass_ = opt_options.clusterClass || \"cluster\";\n\n  if (navigator.userAgent.toLowerCase().indexOf(\"msie\") !== -1) {\n    // Try to avoid IE timeout when processing a huge number of markers:\n    this.batchSize_ = this.batchSizeIE_;\n  }\n\n  this.setupStyles_();\n\n  this.addMarkers(opt_markers, true);\n  this.setMap(map); // Note: this causes onAdd to be called\n}\n\n\n/**\n * Implementation of the onAdd interface method.\n * @ignore\n */\nMarkerClusterer.prototype.onAdd = function () {\n  var cMarkerClusterer = this;\n\n  this.activeMap_ = this.getMap();\n  this.ready_ = true;\n\n  this.repaint();\n\n  // Add the map event listeners\n  this.listeners_ = [\n    google.maps.event.addListener(this.getMap(), \"zoom_changed\", function () {\n      cMarkerClusterer.resetViewport_(false);\n      // Workaround for this Google bug: when map is at level 0 and \"-\" of\n      // zoom slider is clicked, a \"zoom_changed\" event is fired even though\n      // the map doesn't zoom out any further. In this situation, no \"idle\"\n      // event is triggered so the cluster markers that have been removed\n      // do not get redrawn. Same goes for a zoom in at maxZoom.\n      if (this.getZoom() === (this.get(\"minZoom\") || 0) || this.getZoom() === this.get(\"maxZoom\")) {\n        google.maps.event.trigger(this, \"idle\");\n      }\n    }),\n    google.maps.event.addListener(this.getMap(), \"idle\", function () {\n      cMarkerClusterer.redraw_();\n    })\n  ];\n};\n\n\n/**\n * Implementation of the onRemove interface method.\n * Removes map event listeners and all cluster icons from the DOM.\n * All managed markers are also put back on the map.\n * @ignore\n */\nMarkerClusterer.prototype.onRemove = function () {\n  var i;\n\n  // Put all the managed markers back on the map:\n  for (i = 0; i < this.markers_.length; i++) {\n    if (this.markers_[i].getMap() !== this.activeMap_) {\n      this.markers_[i].setMap(this.activeMap_);\n    }\n  }\n\n  // Remove all clusters:\n  for (i = 0; i < this.clusters_.length; i++) {\n    this.clusters_[i].remove();\n  }\n  this.clusters_ = [];\n\n  // Remove map event listeners:\n  for (i = 0; i < this.listeners_.length; i++) {\n    google.maps.event.removeListener(this.listeners_[i]);\n  }\n  this.listeners_ = [];\n\n  this.activeMap_ = null;\n  this.ready_ = false;\n};\n\n\n/**\n * Implementation of the draw interface method.\n * @ignore\n */\nMarkerClusterer.prototype.draw = function () {};\n\n\n/**\n * Sets up the styles object.\n */\nMarkerClusterer.prototype.setupStyles_ = function () {\n  var i, size;\n  if (this.styles_.length > 0) {\n    return;\n  }\n\n  for (i = 0; i < this.imageSizes_.length; i++) {\n    size = this.imageSizes_[i];\n    this.styles_.push({\n      url: this.imagePath_ + (i + 1) + \".\" + this.imageExtension_,\n      height: size,\n      width: size\n    });\n  }\n};\n\n\n/**\n *  Fits the map to the bounds of the markers managed by the clusterer.\n */\nMarkerClusterer.prototype.fitMapToMarkers = function () {\n  var i;\n  var markers = this.getMarkers();\n  var bounds = new google.maps.LatLngBounds();\n  for (i = 0; i < markers.length; i++) {\n    bounds.extend(markers[i].getPosition());\n  }\n\n  this.getMap().fitBounds(bounds);\n};\n\n\n/**\n * Returns the value of the <code>gridSize</code> property.\n *\n * @return {number} The grid size.\n */\nMarkerClusterer.prototype.getGridSize = function () {\n  return this.gridSize_;\n};\n\n\n/**\n * Sets the value of the <code>gridSize</code> property.\n *\n * @param {number} gridSize The grid size.\n */\nMarkerClusterer.prototype.setGridSize = function (gridSize) {\n  this.gridSize_ = gridSize;\n};\n\n\n/**\n * Returns the value of the <code>minimumClusterSize</code> property.\n *\n * @return {number} The minimum cluster size.\n */\nMarkerClusterer.prototype.getMinimumClusterSize = function () {\n  return this.minClusterSize_;\n};\n\n/**\n * Sets the value of the <code>minimumClusterSize</code> property.\n *\n * @param {number} minimumClusterSize The minimum cluster size.\n */\nMarkerClusterer.prototype.setMinimumClusterSize = function (minimumClusterSize) {\n  this.minClusterSize_ = minimumClusterSize;\n};\n\n\n/**\n *  Returns the value of the <code>maxZoom</code> property.\n *\n *  @return {number} The maximum zoom level.\n */\nMarkerClusterer.prototype.getMaxZoom = function () {\n  return this.maxZoom_;\n};\n\n\n/**\n *  Sets the value of the <code>maxZoom</code> property.\n *\n *  @param {number} maxZoom The maximum zoom level.\n */\nMarkerClusterer.prototype.setMaxZoom = function (maxZoom) {\n  this.maxZoom_ = maxZoom;\n};\n\n\n/**\n *  Returns the value of the <code>styles</code> property.\n *\n *  @return {Array} The array of styles defining the cluster markers to be used.\n */\nMarkerClusterer.prototype.getStyles = function () {\n  return this.styles_;\n};\n\n\n/**\n *  Sets the value of the <code>styles</code> property.\n *\n *  @param {Array.<ClusterIconStyle>} styles The array of styles to use.\n */\nMarkerClusterer.prototype.setStyles = function (styles) {\n  this.styles_ = styles;\n};\n\n\n/**\n * Returns the value of the <code>title</code> property.\n *\n * @return {string} The content of the title text.\n */\nMarkerClusterer.prototype.getTitle = function () {\n  return this.title_;\n};\n\n\n/**\n *  Sets the value of the <code>title</code> property.\n *\n *  @param {string} title The value of the title property.\n */\nMarkerClusterer.prototype.setTitle = function (title) {\n  this.title_ = title;\n};\n\n\n/**\n * Returns the value of the <code>zoomOnClick</code> property.\n *\n * @return {boolean} True if zoomOnClick property is set.\n */\nMarkerClusterer.prototype.getZoomOnClick = function () {\n  return this.zoomOnClick_;\n};\n\n\n/**\n *  Sets the value of the <code>zoomOnClick</code> property.\n *\n *  @param {boolean} zoomOnClick The value of the zoomOnClick property.\n */\nMarkerClusterer.prototype.setZoomOnClick = function (zoomOnClick) {\n  this.zoomOnClick_ = zoomOnClick;\n};\n\n\n/**\n * Returns the value of the <code>averageCenter</code> property.\n *\n * @return {boolean} True if averageCenter property is set.\n */\nMarkerClusterer.prototype.getAverageCenter = function () {\n  return this.averageCenter_;\n};\n\n\n/**\n *  Sets the value of the <code>averageCenter</code> property.\n *\n *  @param {boolean} averageCenter The value of the averageCenter property.\n */\nMarkerClusterer.prototype.setAverageCenter = function (averageCenter) {\n  this.averageCenter_ = averageCenter;\n};\n\n\n/**\n * Returns the value of the <code>ignoreHidden</code> property.\n *\n * @return {boolean} True if ignoreHidden property is set.\n */\nMarkerClusterer.prototype.getIgnoreHidden = function () {\n  return this.ignoreHidden_;\n};\n\n\n/**\n *  Sets the value of the <code>ignoreHidden</code> property.\n *\n *  @param {boolean} ignoreHidden The value of the ignoreHidden property.\n */\nMarkerClusterer.prototype.setIgnoreHidden = function (ignoreHidden) {\n  this.ignoreHidden_ = ignoreHidden;\n};\n\n\n/**\n * Returns the value of the <code>enableRetinaIcons</code> property.\n *\n * @return {boolean} True if enableRetinaIcons property is set.\n */\nMarkerClusterer.prototype.getEnableRetinaIcons = function () {\n  return this.enableRetinaIcons_;\n};\n\n\n/**\n *  Sets the value of the <code>enableRetinaIcons</code> property.\n *\n *  @param {boolean} enableRetinaIcons The value of the enableRetinaIcons property.\n */\nMarkerClusterer.prototype.setEnableRetinaIcons = function (enableRetinaIcons) {\n  this.enableRetinaIcons_ = enableRetinaIcons;\n};\n\n\n/**\n * Returns the value of the <code>imageExtension</code> property.\n *\n * @return {string} The value of the imageExtension property.\n */\nMarkerClusterer.prototype.getImageExtension = function () {\n  return this.imageExtension_;\n};\n\n\n/**\n *  Sets the value of the <code>imageExtension</code> property.\n *\n *  @param {string} imageExtension The value of the imageExtension property.\n */\nMarkerClusterer.prototype.setImageExtension = function (imageExtension) {\n  this.imageExtension_ = imageExtension;\n};\n\n\n/**\n * Returns the value of the <code>imagePath</code> property.\n *\n * @return {string} The value of the imagePath property.\n */\nMarkerClusterer.prototype.getImagePath = function () {\n  return this.imagePath_;\n};\n\n\n/**\n *  Sets the value of the <code>imagePath</code> property.\n *\n *  @param {string} imagePath The value of the imagePath property.\n */\nMarkerClusterer.prototype.setImagePath = function (imagePath) {\n  this.imagePath_ = imagePath;\n};\n\n\n/**\n * Returns the value of the <code>imageSizes</code> property.\n *\n * @return {Array} The value of the imageSizes property.\n */\nMarkerClusterer.prototype.getImageSizes = function () {\n  return this.imageSizes_;\n};\n\n\n/**\n *  Sets the value of the <code>imageSizes</code> property.\n *\n *  @param {Array} imageSizes The value of the imageSizes property.\n */\nMarkerClusterer.prototype.setImageSizes = function (imageSizes) {\n  this.imageSizes_ = imageSizes;\n};\n\n\n/**\n * Returns the value of the <code>calculator</code> property.\n *\n * @return {function} the value of the calculator property.\n */\nMarkerClusterer.prototype.getCalculator = function () {\n  return this.calculator_;\n};\n\n\n/**\n * Sets the value of the <code>calculator</code> property.\n *\n * @param {function(Array.<google.maps.Marker>, number)} calculator The value\n *  of the calculator property.\n */\nMarkerClusterer.prototype.setCalculator = function (calculator) {\n  this.calculator_ = calculator;\n};\n\n\n/**\n * Returns the value of the <code>batchSizeIE</code> property.\n *\n * @return {number} the value of the batchSizeIE property.\n */\nMarkerClusterer.prototype.getBatchSizeIE = function () {\n  return this.batchSizeIE_;\n};\n\n\n/**\n * Sets the value of the <code>batchSizeIE</code> property.\n *\n *  @param {number} batchSizeIE The value of the batchSizeIE property.\n */\nMarkerClusterer.prototype.setBatchSizeIE = function (batchSizeIE) {\n  this.batchSizeIE_ = batchSizeIE;\n};\n\n\n/**\n * Returns the value of the <code>clusterClass</code> property.\n *\n * @return {string} the value of the clusterClass property.\n */\nMarkerClusterer.prototype.getClusterClass = function () {\n  return this.clusterClass_;\n};\n\n\n/**\n * Sets the value of the <code>clusterClass</code> property.\n *\n *  @param {string} clusterClass The value of the clusterClass property.\n */\nMarkerClusterer.prototype.setClusterClass = function (clusterClass) {\n  this.clusterClass_ = clusterClass;\n};\n\n\n/**\n *  Returns the array of markers managed by the clusterer.\n *\n *  @return {Array} The array of markers managed by the clusterer.\n */\nMarkerClusterer.prototype.getMarkers = function () {\n  return this.markers_;\n};\n\n\n/**\n *  Returns the number of markers managed by the clusterer.\n *\n *  @return {number} The number of markers.\n */\nMarkerClusterer.prototype.getTotalMarkers = function () {\n  return this.markers_.length;\n};\n\n\n/**\n * Returns the current array of clusters formed by the clusterer.\n *\n * @return {Array} The array of clusters formed by the clusterer.\n */\nMarkerClusterer.prototype.getClusters = function () {\n  return this.clusters_;\n};\n\n\n/**\n * Returns the number of clusters formed by the clusterer.\n *\n * @return {number} The number of clusters formed by the clusterer.\n */\nMarkerClusterer.prototype.getTotalClusters = function () {\n  return this.clusters_.length;\n};\n\n\n/**\n * Adds a marker to the clusterer. The clusters are redrawn unless\n *  <code>opt_nodraw</code> is set to <code>true</code>.\n *\n * @param {google.maps.Marker} marker The marker to add.\n * @param {boolean} [opt_nodraw] Set to <code>true</code> to prevent redrawing.\n */\nMarkerClusterer.prototype.addMarker = function (marker, opt_nodraw) {\n  this.pushMarkerTo_(marker);\n  if (!opt_nodraw) {\n    this.redraw_();\n  }\n};\n\n\n/**\n * Adds an array of markers to the clusterer. The clusters are redrawn unless\n *  <code>opt_nodraw</code> is set to <code>true</code>.\n *\n * @param {Array.<google.maps.Marker>} markers The markers to add.\n * @param {boolean} [opt_nodraw] Set to <code>true</code> to prevent redrawing.\n */\nMarkerClusterer.prototype.addMarkers = function (markers, opt_nodraw) {\n  var key;\n  for (key in markers) {\n    if (markers.hasOwnProperty(key)) {\n      this.pushMarkerTo_(markers[key]);\n    }\n  }  \n  if (!opt_nodraw) {\n    this.redraw_();\n  }\n};\n\n\n/**\n * Pushes a marker to the clusterer.\n *\n * @param {google.maps.Marker} marker The marker to add.\n */\nMarkerClusterer.prototype.pushMarkerTo_ = function (marker) {\n  // If the marker is draggable add a listener so we can update the clusters on the dragend:\n  if (marker.getDraggable()) {\n    var cMarkerClusterer = this;\n    google.maps.event.addListener(marker, \"dragend\", function () {\n      if (cMarkerClusterer.ready_) {\n        this.isAdded = false;\n        cMarkerClusterer.repaint();\n      }\n    });\n  }\n  marker.isAdded = false;\n  this.markers_.push(marker);\n};\n\n\n/**\n * Removes a marker from the cluster.  The clusters are redrawn unless\n *  <code>opt_nodraw</code> is set to <code>true</code>. Returns <code>true</code> if the\n *  marker was removed from the clusterer.\n *\n * @param {google.maps.Marker} marker The marker to remove.\n * @param {boolean} [opt_nodraw] Set to <code>true</code> to prevent redrawing.\n * @return {boolean} True if the marker was removed from the clusterer.\n */\nMarkerClusterer.prototype.removeMarker = function (marker, opt_nodraw) {\n  var removed = this.removeMarker_(marker);\n\n  if (!opt_nodraw && removed) {\n    this.repaint();\n  }\n\n  return removed;\n};\n\n\n/**\n * Removes an array of markers from the cluster. The clusters are redrawn unless\n *  <code>opt_nodraw</code> is set to <code>true</code>. Returns <code>true</code> if markers\n *  were removed from the clusterer.\n *\n * @param {Array.<google.maps.Marker>} markers The markers to remove.\n * @param {boolean} [opt_nodraw] Set to <code>true</code> to prevent redrawing.\n * @return {boolean} True if markers were removed from the clusterer.\n */\nMarkerClusterer.prototype.removeMarkers = function (markers, opt_nodraw) {\n  var i, r;\n  var removed = false;\n\n  for (i = 0; i < markers.length; i++) {\n    r = this.removeMarker_(markers[i]);\n    removed = removed || r;\n  }\n\n  if (!opt_nodraw && removed) {\n    this.repaint();\n  }\n\n  return removed;\n};\n\n\n/**\n * Removes a marker and returns true if removed, false if not.\n *\n * @param {google.maps.Marker} marker The marker to remove\n * @return {boolean} Whether the marker was removed or not\n */\nMarkerClusterer.prototype.removeMarker_ = function (marker) {\n  var i;\n  var index = -1;\n  if (this.markers_.indexOf) {\n    index = this.markers_.indexOf(marker);\n  } else {\n    for (i = 0; i < this.markers_.length; i++) {\n      if (marker === this.markers_[i]) {\n        index = i;\n        break;\n      }\n    }\n  }\n\n  if (index === -1) {\n    // Marker is not in our list of markers, so do nothing:\n    return false;\n  }\n\n  marker.setMap(null);\n  this.markers_.splice(index, 1); // Remove the marker from the list of managed markers\n  return true;\n};\n\n\n/**\n * Removes all clusters and markers from the map and also removes all markers\n *  managed by the clusterer.\n */\nMarkerClusterer.prototype.clearMarkers = function () {\n  this.resetViewport_(true);\n  this.markers_ = [];\n};\n\n\n/**\n * Recalculates and redraws all the marker clusters from scratch.\n *  Call this after changing any properties.\n */\nMarkerClusterer.prototype.repaint = function () {\n  var oldClusters = this.clusters_.slice();\n  this.clusters_ = [];\n  this.resetViewport_(false);\n  this.redraw_();\n\n  // Remove the old clusters.\n  // Do it in a timeout to prevent blinking effect.\n  setTimeout(function () {\n    var i;\n    for (i = 0; i < oldClusters.length; i++) {\n      oldClusters[i].remove();\n    }\n  }, 0);\n};\n\n\n/**\n * Returns the current bounds extended by the grid size.\n *\n * @param {google.maps.LatLngBounds} bounds The bounds to extend.\n * @return {google.maps.LatLngBounds} The extended bounds.\n * @ignore\n */\nMarkerClusterer.prototype.getExtendedBounds = function (bounds) {\n  var projection = this.getProjection();\n\n  // Turn the bounds into latlng.\n  var tr = new google.maps.LatLng(bounds.getNorthEast().lat(),\n      bounds.getNorthEast().lng());\n  var bl = new google.maps.LatLng(bounds.getSouthWest().lat(),\n      bounds.getSouthWest().lng());\n\n  // Convert the points to pixels and the extend out by the grid size.\n  var trPix = projection.fromLatLngToDivPixel(tr);\n  trPix.x += this.gridSize_;\n  trPix.y -= this.gridSize_;\n\n  var blPix = projection.fromLatLngToDivPixel(bl);\n  blPix.x -= this.gridSize_;\n  blPix.y += this.gridSize_;\n\n  // Convert the pixel points back to LatLng\n  var ne = projection.fromDivPixelToLatLng(trPix);\n  var sw = projection.fromDivPixelToLatLng(blPix);\n\n  // Extend the bounds to contain the new bounds.\n  bounds.extend(ne);\n  bounds.extend(sw);\n\n  return bounds;\n};\n\n\n/**\n * Redraws all the clusters.\n */\nMarkerClusterer.prototype.redraw_ = function () {\n  this.createClusters_(0);\n};\n\n\n/**\n * Removes all clusters from the map. The markers are also removed from the map\n *  if <code>opt_hide</code> is set to <code>true</code>.\n *\n * @param {boolean} [opt_hide] Set to <code>true</code> to also remove the markers\n *  from the map.\n */\nMarkerClusterer.prototype.resetViewport_ = function (opt_hide) {\n  var i, marker;\n  // Remove all the clusters\n  for (i = 0; i < this.clusters_.length; i++) {\n    this.clusters_[i].remove();\n  }\n  this.clusters_ = [];\n\n  // Reset the markers to not be added and to be removed from the map.\n  for (i = 0; i < this.markers_.length; i++) {\n    marker = this.markers_[i];\n    marker.isAdded = false;\n    if (opt_hide) {\n      marker.setMap(null);\n    }\n  }\n};\n\n\n/**\n * Calculates the distance between two latlng locations in km.\n *\n * @param {google.maps.LatLng} p1 The first lat lng point.\n * @param {google.maps.LatLng} p2 The second lat lng point.\n * @return {number} The distance between the two points in km.\n * @see http://www.movable-type.co.uk/scripts/latlong.html\n*/\nMarkerClusterer.prototype.distanceBetweenPoints_ = function (p1, p2) {\n  var R = 6371; // Radius of the Earth in km\n  var dLat = (p2.lat() - p1.lat()) * Math.PI / 180;\n  var dLon = (p2.lng() - p1.lng()) * Math.PI / 180;\n  var a = Math.sin(dLat / 2) * Math.sin(dLat / 2) +\n    Math.cos(p1.lat() * Math.PI / 180) * Math.cos(p2.lat() * Math.PI / 180) *\n    Math.sin(dLon / 2) * Math.sin(dLon / 2);\n  var c = 2 * Math.atan2(Math.sqrt(a), Math.sqrt(1 - a));\n  var d = R * c;\n  return d;\n};\n\n\n/**\n * Determines if a marker is contained in a bounds.\n *\n * @param {google.maps.Marker} marker The marker to check.\n * @param {google.maps.LatLngBounds} bounds The bounds to check against.\n * @return {boolean} True if the marker is in the bounds.\n */\nMarkerClusterer.prototype.isMarkerInBounds_ = function (marker, bounds) {\n  return bounds.contains(marker.getPosition());\n};\n\n\n/**\n * Adds a marker to a cluster, or creates a new cluster.\n *\n * @param {google.maps.Marker} marker The marker to add.\n */\nMarkerClusterer.prototype.addToClosestCluster_ = function (marker) {\n  var i, d, cluster, center;\n  var distance = 40000; // Some large number\n  var clusterToAddTo = null;\n  for (i = 0; i < this.clusters_.length; i++) {\n    cluster = this.clusters_[i];\n    center = cluster.getCenter();\n    if (center) {\n      d = this.distanceBetweenPoints_(center, marker.getPosition());\n      if (d < distance) {\n        distance = d;\n        clusterToAddTo = cluster;\n      }\n    }\n  }\n\n  if (clusterToAddTo && clusterToAddTo.isMarkerInClusterBounds(marker)) {\n    clusterToAddTo.addMarker(marker);\n  } else {\n    cluster = new Cluster(this);\n    cluster.addMarker(marker);\n    this.clusters_.push(cluster);\n  }\n};\n\n\n/**\n * Creates the clusters. This is done in batches to avoid timeout errors\n *  in some browsers when there is a huge number of markers.\n *\n * @param {number} iFirst The index of the first marker in the batch of\n *  markers to be added to clusters.\n */\nMarkerClusterer.prototype.createClusters_ = function (iFirst) {\n  var i, marker;\n  var mapBounds;\n  var cMarkerClusterer = this;\n  if (!this.ready_) {\n    return;\n  }\n\n  // Cancel previous batch processing if we're working on the first batch:\n  if (iFirst === 0) {\n    /**\n     * This event is fired when the <code>MarkerClusterer</code> begins\n     *  clustering markers.\n     * @name MarkerClusterer#clusteringbegin\n     * @param {MarkerClusterer} mc The MarkerClusterer whose markers are being clustered.\n     * @event\n     */\n    google.maps.event.trigger(this, \"clusteringbegin\", this);\n\n    if (typeof this.timerRefStatic !== \"undefined\") {\n      clearTimeout(this.timerRefStatic);\n      delete this.timerRefStatic;\n    }\n  }\n\n  // Get our current map view bounds.\n  // Create a new bounds object so we don't affect the map.\n  //\n  // See Comments 9 & 11 on Issue 3651 relating to this workaround for a Google Maps bug:\n  if (this.getMap().getZoom() > 3) {\n    mapBounds = new google.maps.LatLngBounds(this.getMap().getBounds().getSouthWest(),\n      this.getMap().getBounds().getNorthEast());\n  } else {\n    mapBounds = new google.maps.LatLngBounds(new google.maps.LatLng(85.02070771743472, -178.48388434375), new google.maps.LatLng(-85.08136444384544, 178.00048865625));\n  }\n  var bounds = this.getExtendedBounds(mapBounds);\n\n  var iLast = Math.min(iFirst + this.batchSize_, this.markers_.length);\n\n  for (i = iFirst; i < iLast; i++) {\n    marker = this.markers_[i];\n    if (!marker.isAdded && this.isMarkerInBounds_(marker, bounds)) {\n      if (!this.ignoreHidden_ || (this.ignoreHidden_ && marker.getVisible())) {\n        this.addToClosestCluster_(marker);\n      }\n    }\n  }\n\n  if (iLast < this.markers_.length) {\n    this.timerRefStatic = setTimeout(function () {\n      cMarkerClusterer.createClusters_(iLast);\n    }, 0);\n  } else {\n    delete this.timerRefStatic;\n\n    /**\n     * This event is fired when the <code>MarkerClusterer</code> stops\n     *  clustering markers.\n     * @name MarkerClusterer#clusteringend\n     * @param {MarkerClusterer} mc The MarkerClusterer whose markers are being clustered.\n     * @event\n     */\n    google.maps.event.trigger(this, \"clusteringend\", this);\n  }\n};\n\n\n/**\n * Extends an object's prototype by another's.\n *\n * @param {Object} obj1 The object to be extended.\n * @param {Object} obj2 The object to extend with.\n * @return {Object} The new extended object.\n * @ignore\n */\nMarkerClusterer.prototype.extend = function (obj1, obj2) {\n  return (function (object) {\n    var property;\n    for (property in object.prototype) {\n      this.prototype[property] = object.prototype[property];\n    }\n    return this;\n  }).apply(obj1, [obj2]);\n};\n\n\n/**\n * The default function for determining the label text and style\n * for a cluster icon.\n *\n * @param {Array.<google.maps.Marker>} markers The array of markers represented by the cluster.\n * @param {number} numStyles The number of marker styles available.\n * @return {ClusterIconInfo} The information resource for the cluster.\n * @constant\n * @ignore\n */\nMarkerClusterer.CALCULATOR = function (markers, numStyles) {\n  var index = 0;\n  var title = \"\";\n  var count = markers.length.toString();\n\n  var dv = count;\n  while (dv !== 0) {\n    dv = parseInt(dv / 10, 10);\n    index++;\n  }\n\n  index = Math.min(index, numStyles);\n  return {\n    text: count,\n    index: index,\n    title: title\n  };\n};\n\n\n/**\n * The number of markers to process in one batch.\n *\n * @type {number}\n * @constant\n */\nMarkerClusterer.BATCH_SIZE = 2000;\n\n\n/**\n * The number of markers to process in one batch (IE only).\n *\n * @type {number}\n * @constant\n */\nMarkerClusterer.BATCH_SIZE_IE = 500;\n\n\n/**\n * The default root name for the marker cluster images.\n *\n * @type {string}\n * @constant\n */\nMarkerClusterer.IMAGE_PATH = \"https://raw.githubusercontent.com/googlemaps/v3-utility-library/master/markerclustererplus/images/m\";\n\n\n/**\n * The default extension name for the marker cluster images.\n *\n * @type {string}\n * @constant\n */\nMarkerClusterer.IMAGE_EXTENSION = \"png\";\n\n\n/**\n * The default array of sizes for the marker cluster images.\n *\n * @type {Array.<number>}\n * @constant\n */\nMarkerClusterer.IMAGE_SIZES = [53, 56, 66, 78, 90];\n\nmodule.exports = MarkerClusterer\n"],"mappings":"AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAGA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAASA,WAAWA,CAACC,OAAO,EAAEC,MAAM,EAAE;EACpCD,OAAO,CAACE,kBAAkB,CAAC,CAAC,CAACC,MAAM,CAACJ,WAAW,EAAEK,MAAM,CAACC,IAAI,CAACC,WAAW,CAAC;EAEzE,IAAI,CAACC,QAAQ,GAAGP,OAAO;EACvB,IAAI,CAACQ,UAAU,GAAGR,OAAO,CAACE,kBAAkB,CAAC,CAAC,CAACO,eAAe,CAAC,CAAC;EAChE,IAAI,CAACC,OAAO,GAAGT,MAAM;EACrB,IAAI,CAACU,OAAO,GAAG,IAAI;EACnB,IAAI,CAACC,IAAI,GAAG,IAAI;EAChB,IAAI,CAACC,KAAK,GAAG,IAAI;EACjB,IAAI,CAACC,QAAQ,GAAG,KAAK;EAErB,IAAI,CAACC,MAAM,CAACf,OAAO,CAACgB,MAAM,CAAC,CAAC,CAAC,CAAC,CAAC;AACjC;;AAGA;AACA;AACA;AACAjB,WAAW,CAACkB,SAAS,CAACC,KAAK,GAAG,YAAY;EACxC,IAAIC,YAAY,GAAG,IAAI;EACvB,IAAIC,mBAAmB;EACvB,IAAIC,qBAAqB;EAEzB,IAAI,CAACT,IAAI,GAAGU,QAAQ,CAACC,aAAa,CAAC,KAAK,CAAC;EACzC,IAAI,CAACX,IAAI,CAACY,SAAS,GAAG,IAAI,CAAChB,UAAU;EACrC,I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EAChC,IAAI,CAACqC,YAAY,CAACpG,IAAI,CAAC,CAAC;AAC1B,CAAC;;AAGD;AACA;AACA;AACA;AACA;AACA;AACAyF,OAAO,CAACjG,SAAS,CAAC0H,qBAAqB,GAAG,UAAUF,MAAM,EAAE;EAC1D,IAAIP,CAAC;EACL,IAAI,IAAI,CAACP,QAAQ,CAAC6B,OAAO,EAAE;IACzB,OAAO,IAAI,CAAC7B,QAAQ,CAAC6B,OAAO,CAACf,MAAM,CAAC,KAAK,CAAC,CAAC;EAC7C,CAAC,MAAM;IACL,KAAKP,CAAC,GAAG,CAAC,EAAEA,CAAC,GAAG,IAAI,CAACP,QAAQ,CAAC9B,MAAM,EAAEqC,CAAC,EAAE,EAAE;MACzC,IAAIO,MAAM,KAAK,IAAI,CAACd,QAAQ,CAACO,CAAC,CAAC,EAAE;QAC/B,OAAO,IAAI;MACb;IACF;EACF;EACA,OAAO,KAAK;AACd,CAAC;;AAGD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAASuB,eAAeA,CAACC,GAAG,EAAEC,WAAW,EAAEC,WAAW,EAAE;EACtD;EACA;EACA;EACA;EACA;EACA,IAAI,CAACzJ,MAAM,CAACsJ,eAAe,EAAErJ,MAAM,CAACC,IAAI,CAACC,WAAW,CAAC;EAErDqJ,WAAW,GAAGA,WAAW,IAAI,EAAE;EAC/BC,WAAW,GAAGA,WAAW,IAAI,CAAC,CAAC;EAE/B,IAAI,CAACjC,QAAQ,GAAG,EAAE;EAClB,IAAI,CAACkC,SAAS,GAAG,E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"},"metadata":{},"sourceType":"script","externalDependencies":[]}